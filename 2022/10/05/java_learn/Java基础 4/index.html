

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Sean">
  <meta name="keywords" content="">
  
    <meta name="description" content="本章记录 Java 线程基础、IO流、网络编程、多用户即时通信系统、反射、坦克大战等相关内容">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础 第四章">
<meta property="og:url" content="https://nxblog.github.io/2022/10/05/java_learn/Java%E5%9F%BA%E7%A1%80%204/index.html">
<meta property="og:site_name" content="灵感集市">
<meta property="og:description" content="本章记录 Java 线程基础、IO流、网络编程、多用户即时通信系统、反射、坦克大战等相关内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-12-19-06.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-13-19-38.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-14-12-25.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-14-12-54.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-14-17-07.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-14-18-30.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-15-16-08.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-16-09-55.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-17-19-45.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-19-12-20.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-19-13-22.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-20-13-15.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-20-13-16.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-20-13-37.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-20-13-18.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-21-13-01.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-21-12-59.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-23-12-26.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-23-12-31.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-23-16-52.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-24-16-54.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-24-16-48.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-24-17-18.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-24-17-22.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-24-17-59.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-26-11-23.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-26-11-14.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-26-11-15.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-26-12-22.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-26-15-55.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-26-15-59.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-26-19-28.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-27-19-59.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-28-10-22.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-29-11-53.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-29-13-29.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-30-11-02.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-30-11-21.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-01-17-54.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-02-11-55.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-06-20-34.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-14-18-10.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-24-11-46.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-24-12-12.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-24-12-30.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-24-15-07.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-24-15-14.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-26-09-36.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-26-12-33.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-26-12-31.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-26-12-34.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-26-12-35.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/diagrams/Java%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.svg">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-07-29-12-54.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-08-02-10-58.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-08-02-11-00.png">
<meta property="og:image" content="https://nxblog.github.io/img/java_learn/mk-2022-08-03-11-22.png">
<meta property="article:published_time" content="2022-10-05T02:04:00.000Z">
<meta property="article:modified_time" content="2022-10-05T03:53:59.653Z">
<meta property="article:author" content="Sean">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="技术">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://nxblog.github.io/img/java_learn/mk-2022-06-12-19-06.png">
  
  
  
  <title>Java基础 第四章 - 灵感集市</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"nxblog.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sean的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                库
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://hexo.fluid-dev.com/">
                    
                    知识分享
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://hexo.fluid-dev.com/">
                    
                    摄影日记
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://hexo.fluid-dev.com/">
                    
                    经验杂谈
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/bg3.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java基础 第四章"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-05 10:04" pubdate>
          2022年10月5日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          114k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          950 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java基础 第四章</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本章记录 Java 线程基础、IO流、网络编程、多用户即时通信系统、反射、坦克大战等相关内容</p>
</blockquote>
<span id="more"></span>

<h1 id="Java-基础-第四章"><a href="#Java-基础-第四章" class="headerlink" title="Java 基础 第四章"></a>Java 基础 第四章</h1><h2 id="十五、坦克大战-1"><a href="#十五、坦克大战-1" class="headerlink" title="十五、坦克大战 1"></a>十五、坦克大战 1</h2><h3 id="坦克大战介绍"><a href="#坦克大战介绍" class="headerlink" title="坦克大战介绍"></a>坦克大战介绍</h3><ul>
<li><p>坦克大战是一个游戏项目，涉及到 Java 各方面的技术</p>
<ol>
<li>Java 面向对象编程</li>
<li>多线程</li>
<li>文件 I&#x2F;O 操作</li>
<li>数据库</li>
</ol>
</li>
<li><p>项目是从小到大的过程，被分解成不同的版本，从 1.0 到 1.1… 最终版，随版本的增加，将新的功能和新的知识点融入到项目中，整个过程循序渐进，轻松学习，高效掌握 Java 技术</p>
</li>
</ul>
<h3 id="Java-绘图坐标体系"><a href="#Java-绘图坐标体系" class="headerlink" title="Java 绘图坐标体系"></a>Java 绘图坐标体系</h3><p>下图说明了 Java 坐标系。坐标原点位于左上角，以<strong>像素</strong>为单位<br>第一个是 x 坐标，表示当前位置为水平方向，距离坐标原点 x 个像素<br>第二个是 y 坐标，表示当前位置为垂直方向，举例坐标原点 y 个元素</p>
<p><img src="/img/java_learn/mk-2022-06-12-19-06.png" srcset="/img/loading.gif" lazyload alt="Java 绘图坐标体系"></p>
<p>像素是一个<strong>密度单位</strong>，而厘米是<strong>长度单位</strong>，两者无法比较</p>
<h3 id="Java-绘图技术"><a href="#Java-绘图技术" class="headerlink" title="Java 绘图技术"></a>Java 绘图技术</h3><ol>
<li><p>绘图原理</p>
<p> <code>Component</code> 类提供了两个和绘图相关最重要的方法：</p>
<ol>
<li><code>paint(Graphics g)</code>: 绘制组件的外观</li>
<li><code>repaint()</code>: 刷新组件的外观</li>
</ol>
<p> 当组件第一次在屏幕显示的时候，程序会自动的调用 <code>paint()</code> 方法来绘制组件<br> 在以下情况 <code>paint()</code> 将会被调用：</p>
<ol>
<li>窗口最小化再还原，或者最大化</li>
<li>窗口的大小发生变化</li>
<li><code>repaint()</code> 方法被调用</li>
</ol>
</li>
<li><p>快速入门案例</p>
<ul>
<li><p>画出一个圆</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span> &#123; <span class="hljs-comment">// JFrame: 绘图框架/画框</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MyPanel</span> <span class="hljs-variable">mp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawCircle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DrawCircle</span><span class="hljs-params">()</span> &#123;<br>        mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPanel</span>();<br><br>        <span class="hljs-comment">// 把面板放入到窗口</span><br>        <span class="hljs-built_in">this</span>.add(mp);<br><br>        <span class="hljs-comment">// 设置窗口的大小</span><br>        <span class="hljs-built_in">this</span>.setSize(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>);<br><br>        <span class="hljs-comment">// 当关闭窗口时，程序完全退出</span><br>        <span class="hljs-built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br><br>        <span class="hljs-comment">// 使窗口可视化</span><br>        <span class="hljs-built_in">this</span>.setVisible(<span class="hljs-literal">true</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPanel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JPanel</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * MyPanel: 画板</span><br><span class="hljs-comment">    * Graphics g: 画笔</span><br><span class="hljs-comment">    * Graphics 提供很多绘图方法</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>        <span class="hljs-built_in">super</span>.paint(g);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 绘制椭圆的边框。得到一个圆或椭圆，</span><br><span class="hljs-comment">        * 它刚好能放入由 x、y、width 和 height 参数指定的矩形中。</span><br><span class="hljs-comment">        * 椭圆覆盖区域的宽度为 width + 1 像素，高度为 height + 1 像素。</span><br><span class="hljs-comment">        * 参数：</span><br><span class="hljs-comment">        * x - 要绘制椭圆的左上角的 x 坐标。</span><br><span class="hljs-comment">        * y - 要绘制椭圆的左上角的 y 坐标。</span><br><span class="hljs-comment">        * width - 要绘制椭圆的宽度。</span><br><span class="hljs-comment">        * height - 要绘制椭圆的高度。</span><br><span class="hljs-comment">        */</span><br>        g.drawOval(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Graphics 类</p>
<ol>
<li>画直线: <code>drawLine(int x1, int y1, int x2, int y2)</code></li>
<li>画矩形边框: <code>drawRect(int x,int y, int width, int height)</code></li>
<li>画椭圆边框: <code>drawOval(int x,int y, int width, int height)</code></li>
<li>填充矩形: <code>fillRect(int x,int y, int width, int height)</code></li>
<li>填充椭圆: <code>fillOval(int x,int y, int width, int height)</code></li>
<li>画图片: <code>drawImage(Image img/java_learn, int x, int y, ..)</code></li>
<li>画字符串: <code>drawString(String str, int x, int y)</code></li>
<li>设置画笔的字体: <code>setFont(Font font)</code></li>
<li>设置画笔的颜色: <code>setColor(Color c)</code></li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 Graphics 类的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphicsMethod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span> &#123;<br>    <span class="hljs-comment">// private A a = null;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphicsMethod</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GraphicsMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br><br>        <span class="hljs-comment">// 把面板放入到窗口</span><br>        <span class="hljs-built_in">this</span>.add(a);<br><br>        <span class="hljs-built_in">this</span>.setSize(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br><br>        <span class="hljs-built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br><br>        <span class="hljs-built_in">this</span>.setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JPanel</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>        <span class="hljs-built_in">super</span>.paint(g);<br><br>        <span class="hljs-comment">// 画直线: drawLine(int x1, int y1, int x2, int y2)</span><br>        g.drawLine(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 画矩形边框: drawRect(int x,int y, int width, int height)</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 源码：</span><br><span class="hljs-comment">        * g.drawLine(x, y, x + width - 1, y);</span><br><span class="hljs-comment">        * g.drawLine(x + width, y, x + width, y + height - 1);</span><br><span class="hljs-comment">        * g.drawLine(x + width, y + height, x + 1, y + height);</span><br><span class="hljs-comment">        * g.drawLine(x, y + height, x, y + 1);</span><br><span class="hljs-comment">        */</span><br>        g.drawRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">500</span>, <span class="hljs-number">200</span>);<br><br>        <span class="hljs-comment">// 画椭圆边框: drawOval(int x,int y, int width, int height)</span><br>        g.drawOval(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br><br>        <span class="hljs-comment">// 填充矩形: fillRect(int x,int y, int width, int height)</span><br>        g.setColor(Color.RED); <span class="hljs-comment">// 设置画笔颜色</span><br>        g.fillRect(<span class="hljs-number">10</span>, <span class="hljs-number">250</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br><br>        <span class="hljs-comment">// 填充椭圆: fillOval(int x,int y, int width, int height)</span><br>        g.fillOval(<span class="hljs-number">20</span>, <span class="hljs-number">80</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 画图片: drawImage(Image img/java_learn, int x, int y, ..)</span><br>        <span class="hljs-comment">// g.drawImage(img/java_learn, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);</span><br><br>        <span class="hljs-comment">// 画字符串: drawString(String str, int x, int y)</span><br>        <span class="hljs-comment">// 此处 x, y 为文字左下角 </span><br>        g.drawString(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">500</span>);<br>        <br>        <span class="hljs-comment">// 设置画笔的字体: setFont(Font font)</span><br>        g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;黑体&quot;</span>, Font.BOLD, <span class="hljs-number">15</span>));<br><br>        <span class="hljs-comment">// 设置画笔的颜色: setColor(Color c)</span><br>        g.setColor(Color.BLUE);<br>        g.drawString(<span class="hljs-string">&quot;蓝色 15 号字体&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">520</span>);<br><br>        <span class="hljs-comment">// 三角形</span><br>        g.drawLine(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>, <span class="hljs-number">500</span>, <span class="hljs-number">250</span>);<br>        g.drawLine(<span class="hljs-number">300</span>, <span class="hljs-number">250</span>, <span class="hljs-number">400</span>, <span class="hljs-number">375</span>);<br>        g.drawLine(<span class="hljs-number">400</span>, <span class="hljs-number">375</span>, <span class="hljs-number">500</span>, <span class="hljs-number">250</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="Java-事件处理机制"><a href="#Java-事件处理机制" class="headerlink" title="Java 事件处理机制"></a>Java 事件处理机制</h3><ol>
<li><p>基本介绍</p>
<p> Java 事件处理是采取「委派事件模型」。当事件发生时，产生事件的对象，会把此「信息」传递给「事件的监听者」处理，这里所说的「信息」实际上就是 <code>java.awt.event</code> 事件类库里某个类所创建的对象，把它称为「事件的对象」<br> <img src="/img/java_learn/mk-2022-06-13-19-38.png" srcset="/img/loading.gif" lazyload alt="Java 事件处理机制"></p>
<ol>
<li>事件源：事件源是一个产生事件的对象，比如按钮，窗口等。</li>
<li>事件：事件就是承载<strong>事件源</strong>状态改变时的对象，比如当键盘事件、鼠标事件、窗口事件等等，会生成一个事件对象，该对象保存着当前事件很多信息，比如 <code>KeyEvent</code> 对象有含义被按下键的 <code>Code</code> 值。<code>java.awt.event</code> 包和<code>java.swing.event</code> 包中定义了各种事件类型</li>
<li>事件监听器接口<ol>
<li>当事件源产生一个事件，可以传送给事件监听者处理</li>
<li>事件监听者实际上就是一个类，该类实现了某个事件监听器接口，比如前面案例中的 <code>MyPanel</code> 就是一个类，它实现了 <code>KeyListener</code> 接口，它就可以作为一个事件监听者，对接受到的事件进行处理</li>
<li>事件监听器接口有多种，不同的事件监听器接口可以监听不同的事件，一个类可以实现<strong>多个</strong>监听接口</li>
<li>这些接口在 <code>java.awt.event</code> 包和 <code>java.swing.event</code> 包中定义</li>
</ol>
</li>
</ol>
</li>
<li><p>案例演示</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Java 的事件控制</span><br><span class="hljs-comment"> * 演示小球通过键盘控制上下左右的移动</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BallMove</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span> &#123;<br>    <span class="hljs-type">MyPanel</span> <span class="hljs-variable">mp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BallMove</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BallMove</span><span class="hljs-params">()</span> &#123;<br>        mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPanel</span>();<br>        <span class="hljs-built_in">this</span>.add(mp);<br>        <span class="hljs-built_in">this</span>.setSize(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>);<br><br>        <span class="hljs-comment">// 窗口 JFrame 对象可以监听面板内发生的键盘事件</span><br>        <span class="hljs-built_in">this</span>.addKeyListener(mp);<br>        <span class="hljs-built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>        <span class="hljs-built_in">this</span>.setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 面板，可以画出小球</span><br><span class="hljs-comment">// KeyListener 是监听器，可以监听键盘事件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPanel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JPanel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">KeyListener</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>        <span class="hljs-built_in">super</span>.paint(g);<br>        g.fillOval(x, y, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 有字符输出时，该方法会触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyTyped</span><span class="hljs-params">(KeyEvent e)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 当某个键按下，该方法会触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyPressed</span><span class="hljs-params">(KeyEvent e)</span> &#123;<br>        System.out.println(e.getKeyChar() + <span class="hljs-string">&quot;键被触发&quot;</span>);<br><br>        <span class="hljs-comment">// 根据不同的按键，处理小球的移动</span><br>        <span class="hljs-keyword">if</span> (e.getKeyCode() == KeyEvent.VK_DOWN) &#123;<br>            y += <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getKeyCode() == KeyEvent.VK_UP) &#123;<br>            y -= <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getKeyCode() == KeyEvent.VK_LEFT) &#123;<br>            x -= <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getKeyCode() == KeyEvent.VK_RIGHT) &#123;<br>            x += <span class="hljs-number">3</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 画板重绘</span><br>        <span class="hljs-built_in">this</span>.repaint();<br>    &#125;<br><br>    <span class="hljs-comment">// 当某个键释放，该方法会触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyReleased</span><span class="hljs-params">(KeyEvent e)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="坦克大战-1"><a href="#坦克大战-1" class="headerlink" title="坦克大战 1"></a>坦克大战 1</h3><ul>
<li>坦克大战：<ol>
<li>绘制我方坦克</li>
<li>绘制敌方坦克</li>
<li>我方坦克使用监听键盘事件控制移动<br><a href="../myJava/src/com/chapter15/tankgame/TankGame01.java">坦克大战游戏（1.0 版）</a></li>
</ol>
</li>
</ul>
<h2 id="十六、Java-线程基础"><a href="#十六、Java-线程基础" class="headerlink" title="十六、Java 线程基础"></a>十六、Java 线程基础</h2><h3 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h3><ul>
<li><p>程序</p>
<ul>
<li>程序是为完成特定任务、用某种语言编写的一组指令的集合</li>
</ul>
</li>
<li><p>进程</p>
<ul>
<li>进程是指<strong>运行中</strong>的程序，比如我们使用 QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间。</li>
<li>进程是程序的一次执行过程，或是正在运行的一个程序。进程是<strong>动态过程</strong>，有它自身的产生、存在和消亡的过程</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li>线程由进程创建的，是进程的一个实体</li>
<li>一个进程可以拥有多个线程</li>
</ul>
</li>
<li><p>其他相关概念</p>
<ul>
<li>单线程：同一个时刻，只允许执行一个线程</li>
<li>多线程：同一个时刻，可以执行多个线程，比如：一个 QQ 进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</li>
<li>并发：同一个时刻，多个任务交替执行，造成一种「貌似同时」的错觉，简单的说，单核 cpu 实现的多任务就是并发</li>
<li>并行：同一个时刻，多个任务同时执行。多核 cpu 可以实现并行。并发和并行也可能同时使用</li>
</ul>
</li>
</ul>
<h3 id="线程使用（重点）"><a href="#线程使用（重点）" class="headerlink" title="线程使用（重点）"></a>线程使用（重点）</h3><h4 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h4><p><img src="/img/java_learn/mk-2022-06-14-12-25.png" srcset="/img/loading.gif" lazyload alt="Thread 类图"></p>
<ol>
<li>继承 <code>Thread</code> 类，重写 <code>run</code> 方法<ol>
<li>当一个类继承了 <code>Thread</code> 类，该类就可以当做线程使用</li>
<li>重写 <code>run()</code> 方法，写上自己的业务代码</li>
<li><code>Thread</code> 类 <code>run()</code> 方法实现了 <code>Runnable</code> 接口的 <code>run()</code> 方法</li>
<li>使用 <code>start()</code> 方法启动线程</li>
<li>主线程和子线程交替执行</li>
</ol>
</li>
<li>实现 <code>Runnable</code> 接口，重写 <code>run</code> 方法<ol>
<li><p>Java 是单继承的，在某些情况下，一个类可能已经继承了某个父类，这时无法使用继承 <code>Thread</code> 类方法来创建线程</p>
</li>
<li><p>Java 设计者们提供了另一个方式创建线程，就是通过实现 <code>Runnable</code> 接口来创建线程</p>
</li>
<li><p>底层使用了设计模式：代理模式</p>
</li>
<li><p>模拟简单的 Thread 类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 线程代理类，模拟简单的 Thread 类</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Tiger</span> <span class="hljs-variable">tiger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>();<br>        <span class="hljs-type">ThreadProxy</span> <span class="hljs-variable">threadProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadProxy</span>(tiger);<br>        threadProxy.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 类...&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Runnable 类型的属性</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run(); <span class="hljs-comment">// 动态绑定 target 的运行类型：Tiger</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadProxy</span><span class="hljs-params">(Runnable target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        start0(); <span class="hljs-comment">// 真正实现多线程的方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span> &#123;<br>        run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="线程的应用与分析"><a href="#线程的应用与分析" class="headerlink" title="线程的应用与分析"></a>线程的应用与分析</h4><ol>
<li><p>继承 <code>Thread</code> 类</p>
<ol>
<li>请编写程序开启一个线程，该线程每隔 1 秒在控制台输出「我是一只猫」</li>
<li>当输出 8 次「我是一只猫」，结束该线程</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 通过继承 Thread 类创建线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建 Cat 对象，可以当做线程使用</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 启动线程，最终会执行 cat 的 run() 方法</span><br><span class="hljs-comment">        * run() 方法就是一个普通的方法，没有真正的启动一个线程</span><br><span class="hljs-comment">        */</span><br>        cat.start(); <span class="hljs-comment">// 启动线程</span><br><br>        <span class="hljs-comment">// 当 main 线程启动一个子线程 Thread-0，主线程不会阻塞，会继续执行</span><br>        <span class="hljs-comment">// 这时，主线程和子线程交替执行</span><br>        System.out.println();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程执行 &quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; 线程名：&quot;</span> + Thread.currentThread().getName());<br><br>            <span class="hljs-comment">// 让主线程休眠</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 1. 当一个类继承了 Thread 类，该类就可以当做线程使用</span><br><span class="hljs-comment">* 2. 重写 run() 方法，写上自己的业务代码</span><br><span class="hljs-comment">* 3. Thread 类 run() 方法实现了 Runnable 接口的 run() 方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 重写 run() 方法，实现业务逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">8</span>) &#123;<br>            <span class="hljs-comment">// 该线程每隔 1 秒，在控制台输出「我是一只猫」</span><br>            System.out.println(<span class="hljs-string">&quot;我是一只猫 &quot;</span> + ++count + <span class="hljs-string">&quot; 线程名：&quot;</span> + Thread.currentThread().getName());<br><br>            <span class="hljs-comment">// 让该线程休眠 1 秒</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>JConsole</code> 监控线程执行情况，并画出程序示意图<br>   <em>只有当所有<strong>线程</strong>结束时，<strong>进程</strong>才会退出</em><br>   <img src="/img/java_learn/mk-2022-06-14-12-54.png" srcset="/img/loading.gif" lazyload alt="程序示意图"></p>
<ol>
<li><p>分析</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//(1) start() 方法调用 start0() 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    start0();<br>&#125;<br><span class="hljs-comment">// (2)</span><br><span class="hljs-comment">// start0() 是本地方法，由 JVM 调用，底层是 c/c++ 实现</span><br><span class="hljs-comment">// 真正实现多线程的效果，是 start0()，而不是 run</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<p> <img src="/img/java_learn/mk-2022-06-14-17-07.png" srcset="/img/loading.gif" lazyload alt="线程调用"></p>
</li>
</ol>
</li>
<li><p>实现 <code>Runnable</code> 接口</p>
<ol>
<li>编写程序，该程序可以每隔 1 秒，在控制台输出「hi」，当输出 10 次后，自动输出</li>
<li>使用实现 <code>Runnable</code> 接口的方式实现</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 通过实现 Runnable 来开发线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><br>        <span class="hljs-comment">// 不能直接调用 start() 方法</span><br>        <span class="hljs-comment">// 创建 Thread 对象，把 dog 对象（实现 Runnable）放入 Thread</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(dog);<br>        thread.start();<br><br>        System.out.println(<span class="hljs-string">&quot;main 方法继续执行&quot;</span>);<br><br>        <span class="hljs-comment">// 主线程和子线程交替执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(i + <span class="hljs-string">&quot; main 方法线程名 &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-comment">// 让主线程休眠</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + ++count + <span class="hljs-string">&quot; 线程名：&quot;</span> + Thread.currentThread().getName());<br><br>            <span class="hljs-comment">// 休眠一秒</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>多线程执行</p>
<ul>
<li>编写程序，创建两个线程，一个线程每隔 1 秒输出「hello, world」，输出 10 次，退出，另一个线程每隔 1 秒输出「hi」，输出 5 次退出</li>
<li>多线程执行示意图<br>  <img src="/img/java_learn/mk-2022-06-14-18-30.png" srcset="/img/loading.gif" lazyload alt="多线程执行示意图"></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 多线程执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 第一个线程</span><br>        <span class="hljs-type">T1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T1</span>();<br>        t1.start();<br><br>        <span class="hljs-comment">// 第二个线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">T2</span>()); <span class="hljs-comment">// 匿名对象</span><br>        thread.start();<br><br>        System.out.println(<span class="hljs-string">&quot;main 线程结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用继承 Thread 类的方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 每隔 1 秒输出「hello, world」，输出 10 次，退出</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(++count + <span class="hljs-string">&quot; hello, world 线程: &quot;</span> + Thread.currentThread().getName());<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">50</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用实现 Runnable 接口的方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 每隔 1 秒输出「hi」，输出 5 次退出</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(++count + <span class="hljs-string">&quot; hi 线程: &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">60</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="继承-Thread-类与-实现-Runnable-接口的区别"><a href="#继承-Thread-类与-实现-Runnable-接口的区别" class="headerlink" title="继承 Thread 类与 实现 Runnable 接口的区别"></a>继承 Thread 类与 实现 Runnable 接口的区别</h4><ol>
<li><p>从 Java 的设计来看，通过继承 <code>Thread</code> 或者实现 <code>Runnable</code> 接口来创建线程本质上没有区别，从 JDK 帮助文档我们可以看到 <code>Thread</code> 类本身就实现了 <code>Runnable</code> 接口</p>
</li>
<li><p>实现 <code>Runnable</code> 接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用 <code>Runnable</code> 接口</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T3</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T3</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 实现 Runnable 接口</span><br><br><span class="hljs-comment">// 两个线程执行一个 t3 对象，共享资源</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t3);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t3);<br>thread01.start();<br>thread02.start();<br><br>System.out.println(<span class="hljs-string">&quot;主线程执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="售票系统"><a href="#售票系统" class="headerlink" title="售票系统"></a>售票系统</h4><ul>
<li>编程模拟三个售票窗口售票，分别使用继承 Thread 和实现 Runnable 接口的方式，并分析问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 模拟售票</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTicket</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>      <span class="hljs-comment">// 第一种方式</span><br>      <span class="hljs-comment">// 这里会超卖，三个线程互相抢占资源</span><br>      <span class="hljs-comment">// new Sell01().start(); // 1 号窗口</span><br>      <span class="hljs-comment">// new Sell01().start(); // 2 号窗口</span><br>      <span class="hljs-comment">// new Sell01().start(); // 3 号窗口</span><br><br>      <span class="hljs-comment">// 第二种方式</span><br>      <span class="hljs-comment">// 这里仍然会超卖</span><br>      <span class="hljs-type">Sell02</span> <span class="hljs-variable">sell02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sell02</span>();<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell02).start(); <span class="hljs-comment">// 1 号窗口</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell02).start(); <span class="hljs-comment">// 2 号窗口</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell02).start(); <span class="hljs-comment">// 3 号窗口</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承 Thread 接口模拟售票</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sell01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 多个线程共享</span><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>          System.out.println(<span class="hljs-string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 售出 1 张，还有 &quot;</span> + --ticketNums + <span class="hljs-string">&quot; 张票&quot;</span>);<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              Thread.sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// 休眠 5 毫秒</span><br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (ticketNums == <span class="hljs-number">0</span>) &#123;<br>              System.out.println(<span class="hljs-string">&quot;售票结束&quot;</span>);<br>              <span class="hljs-keyword">return</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 Runnable 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sell02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 余票</span><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>          System.out.println(<span class="hljs-string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 售出 1 张，还有 &quot;</span> + --ticketNums + <span class="hljs-string">&quot; 张票&quot;</span>);<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              Thread.sleep(<span class="hljs-number">5</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (ticketNums &lt; <span class="hljs-number">0</span>) &#123;<br>              System.out.println(<span class="hljs-string">&quot;售票结束&quot;</span>);<br>              <span class="hljs-keyword">break</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="线程终止（通知方式）"><a href="#线程终止（通知方式）" class="headerlink" title="线程终止（通知方式）"></a>线程终止（通知方式）</h4><ol>
<li>当线程完成任务后，会自动退出</li>
<li>通过<strong>使用变量</strong>来控制 <code>run()</code> 方法停止线程，即通知方式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 启动一个线程 t，要求在 main 线程中停止线程 t</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExit</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>       thread.start();<br><br>       <span class="hljs-comment">// 如果希望 main 线程去控制 t 线程的终止，可以修改 loop</span><br>       <span class="hljs-comment">// 让 t 退出 run() 方法，从而终止 t 线程 -&gt; 通知方式</span><br><br>       System.out.println(<span class="hljs-string">&quot;主线程休眠 10 秒&quot;</span>);<br>       Thread.sleep(<span class="hljs-number">10000</span>); <span class="hljs-comment">// 主线程休眠 10 秒</span><br>       t.setLoop(<span class="hljs-literal">false</span>);<br><br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">// 设置一个控制变量</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">while</span> (loop) &#123;<br>           System.out.println(<span class="hljs-string">&quot;线程 T 运行中...&quot;</span> + count++);<br><br>           <span class="hljs-keyword">try</span> &#123;<br>               Thread.sleep(<span class="hljs-number">100</span>);<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLoop</span><span class="hljs-params">(<span class="hljs-type">boolean</span> loop)</span> &#123;<br>       <span class="hljs-built_in">this</span>.loop = loop;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><ol>
<li><p>常用方法 1</p>
<ol>
<li><code>setName</code>: 设置线程名称，使之与参数 <code>name</code> 相同</li>
<li><code>getName</code>: 返回该线程的名称</li>
<li><code>start</code>: 使该线程开始执行，Java 虚拟机底层调用该线程的 <code>start0()</code> 方法。start() 底层会创建新的线程，调用 run()，run() 就是一个简单的方法调用，不会启动新线程</li>
<li><code>run</code>: 调用线程对像 <code>run()</code> 方法</li>
<li><code>setPriority</code>: 更改线程的优先级。三个常用的优先级：<code>MIN_PRIORITY = 1; NORM_PRIORITY = 5; MAX_PRIORITY = 10;</code></li>
<li><code>getPriority</code>: 获取线程的优先级</li>
<li><code>sleep</code>: 线程的静态方法，在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</li>
<li><code>interrupt</code>: 中断线程，但并没有正真的结束线程。所以一般用于中断正在休眠的线程</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 测试 Thread 相关的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TT</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TT</span>();<br>        t.setName(<span class="hljs-string">&quot;TT&quot;</span>); <span class="hljs-comment">// 设置线程名</span><br>        t.setPriority(Thread.MIN_PRIORITY); <span class="hljs-comment">// 设置优先级</span><br>        t.getName(); <span class="hljs-comment">// 获取线程名称</span><br>        t.start();<br><br>        <span class="hljs-comment">// 主线程打印 5 个 hi，中断子线程的休眠</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + i);<br>        &#125;<br><br>        System.out.println(t.getName() + <span class="hljs-string">&quot;的优先级：&quot;</span> + t.getPriority());<br>        t.interrupt();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TT</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运行中...&quot;</span> + i);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 休眠中...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">20000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// 当该线程执行到一个 interrupt() 方法时，就会 catch 一个异常，可以加入自己的业务代码</span><br>                <span class="hljs-comment">// InterruptedException 是捕获一个中断异常</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 被 interrupt 了...&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>常用方法 2</p>
<ol>
<li><code>yield</code>: 线程的礼让。让出 <code>CPU</code>，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。如有 <code>t1</code> 和 <code>t2</code> 两个线程，<code>t1</code> 调用 <code>yield()</code> 方法，会发生礼让，但不一定成功</li>
<li><code>join</code>: 线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务。如有 <code>t1</code> 和 <code>t2</code> 两个线程，<code>t1</code> 调用 <code>t2.join()</code> 方法，则在当前位置需要先把 <code>t2</code> 执行完毕，再继续执行 <code>t1</code></li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 测试 Thread 相关的方法</span><br><span class="hljs-comment"> * 创建一个子线程，每隔 1s 输出 hello ，输出 20 次，主线程每隔 1 秒，输出 hi，输出 20 次</span><br><span class="hljs-comment"> * 要求：两个线程同时执行，当主线程输出 5 次后，就让子线程运行完毕，主线程再继续</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadMethod02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TT1</span> <span class="hljs-variable">tt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TT1</span>();<br>        tt1.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程-hi...&quot;</span> + i);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-comment">// join(): 线程插队</span><br>                System.out.println(<span class="hljs-string">&quot;子线程插队&quot;</span>);<br>                tt1.join(); <span class="hljs-comment">// 让子线程先执行完毕</span><br>            <br>                <span class="hljs-comment">// yield(): 线程礼让，不一定成功</span><br>                <span class="hljs-comment">// Thread.yield();</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TT1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程-hello...&quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方法练习</p>
<ol>
<li>主线程每隔 1 秒，输出 <code>hi</code>，一共 10 次</li>
<li>当输出到 <code>hi -5</code> 时，启动一个子线程（要求实现 <code>Runnable</code>），每隔 1 秒输出 <code>hello</code>，等该线程输出 10 次 <code>hello</code> 后，退出</li>
<li>主线程继续输出 <code>hi</code>，直到主线程退出，</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadMethodExercise</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">T3</span>());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;hi -&quot;</span> + i);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) &#123;<br>                thread.start(); <span class="hljs-comment">// 启动主线程</span><br>                thread.join(); <span class="hljs-comment">// 将 t3 子线程插入到主线程</span><br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;主线程结束...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                System.out.println(<span class="hljs-string">&quot;hello -&quot;</span> + i);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;子线程结束...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>用户线程和守护线程</p>
<ol>
<li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束</li>
<li>守护线程：一般是为工作线程服务的，<strong>当所有的用户线程结束，守护线程自动结束</strong></li>
<li>常见的守护线程：垃圾回收机制</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadMethod03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyDaemonThread</span> <span class="hljs-variable">myDaemonThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDaemonThread</span>();<br>        <span class="hljs-comment">// 如果希望当 main 线程结束后，子线程自动结束</span><br>        <span class="hljs-comment">// 只需将子线程设置为守护线程即可</span><br>        myDaemonThread.setDaemon(<span class="hljs-literal">true</span>);<br><br>        myDaemonThread.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;hi...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDaemonThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;hello...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ol>
<li><p>JDK 中用 Thread.State 枚举表示了线程的几种状态</p>
<ul>
<li><code>NEW</code>: 新建<br> 至今尚未启动的线程处于这种状态</li>
<li><code>RUNNABLE</code>: 可运行<br>  正在 Java 虚拟机中执行的线程处于这种状态<ul>
<li><em>有些书把 <code>Runnable</code> 状态分为两个状态，由调度器来执行</em><ul>
<li><code>Ready</code>: 就绪</li>
<li><code>Running</code>: 运行</li>
</ul>
</li>
</ul>
</li>
<li><code>BLOCKED</code>: 阻塞<br>  受阻塞并等待某个监视器锁的线程处于这种状态</li>
<li><code>WAITING</code>: 等待<br>  无限期地等待另一个线程来执行某一特定操作的线程处于这种状态</li>
<li><code>TIMED_WAITING</code>: 超时等待<br>  等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态</li>
<li><code>TERMINATED</code>: 终止<br>  已退出的线程处于这种状态</li>
</ul>
</li>
<li><p>线程状态转换图<br> <img src="/img/java_learn/mk-2022-06-15-16-08.png" srcset="/img/loading.gif" lazyload alt="线程状态转换图"></p>
<ul>
<li>编写程序查看线程状态</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        System.out.println(t.getName() + <span class="hljs-string">&quot;状态：&quot;</span> + t.getState());<br>        t.start();<br><br>        <span class="hljs-keyword">while</span> (Thread.State.TERMINATED != t.getState()) &#123;<br>            System.out.println(t.getName() + <span class="hljs-string">&quot;状态：&quot;</span> + t.getState());<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125;<br><br>        System.out.println(t.getName() + <span class="hljs-string">&quot;状态：&quot;</span> + t.getState());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + i);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="同步-Synchronized（重点）"><a href="#同步-Synchronized（重点）" class="headerlink" title="同步 Synchronized（重点）"></a>同步 Synchronized（重点）</h3><h4 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h4><ol>
<li><p>在多线程编程，一些敏感数据<strong>不允许被多个线程同时访问</strong>，此时就使用同步访问技术，保证<strong>数据在任何同一时刻，最多有一个线程访问</strong>，以保证数据的完整性</p>
</li>
<li><p>也可以这样理解：当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p>
</li>
</ol>
<h4 id="同步具体方法-Synchronized"><a href="#同步具体方法-Synchronized" class="headerlink" title="同步具体方法-Synchronized"></a>同步具体方法-Synchronized</h4><ol>
<li><p>同步代码块</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123; <span class="hljs-comment">// 得到对象的锁，才能操作同步代码</span><br>    <span class="hljs-comment">// 需要被同步的对象</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>放在方法声明中，表示整个方法为同步方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// 需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="使用线程同步解决超卖问题"><a href="#使用线程同步解决超卖问题" class="headerlink" title="使用线程同步解决超卖问题"></a>使用线程同步解决超卖问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTicket</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 第三种方式，使用同步方法 synchronized</span><br>        <span class="hljs-type">Sell03</span> <span class="hljs-variable">sell03</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sell03</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell03).start(); <span class="hljs-comment">// 1 号窗口</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell03).start(); <span class="hljs-comment">// 2 号窗口</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell03).start(); <span class="hljs-comment">// 3 号窗口</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 Runnable 接口，使用同步方法 synchronized 实现线程同步</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sell03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 余票</span><br><br>    <span class="hljs-comment">// 同步方法，在同一时刻，只能有一个线程来执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (ticketNums &lt;= <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        System.out.println(<span class="hljs-string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 售出 1 张，还有 &quot;</span> + --ticketNums + <span class="hljs-string">&quot; 张票&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">// 休眠 10 毫秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (sell()) &#123;<br>            <span class="hljs-comment">// sell() 方法是同步方法，在同一时刻，只能有一个线程来执行</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="互斥锁（重点）"><a href="#互斥锁（重点）" class="headerlink" title="互斥锁（重点）"></a>互斥锁（重点）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>在 Java 语言中，引入了<strong>对象互斥锁</strong>的概念，来保证共享数据操作的完整性</li>
<li>每个对象都对应于一个可称为「互斥锁」的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</li>
<li>关键字 <code>synchronized</code> 来与对象的互斥锁联系。当某个对象用 <code>synchronized</code> 修饰时，表明该对象在任一时刻只能由一个线程访问</li>
<li>同步的局限性：导致程序的<strong>执行效率降低</strong></li>
<li><strong>非静态同步方法</strong>的锁可以是 <code>this</code>，也可以是其他对象（要求每个线程是同一个对象）</li>
<li><strong>静态同步方法</strong>的锁为<strong>当前类</strong>本身</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">* 模拟三个售票窗口（优化）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTicket</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 第三种方式，使用同步方法 synchronized</span><br>      <span class="hljs-type">Sell03</span> <span class="hljs-variable">sell03</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sell03</span>();<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell03).start(); <span class="hljs-comment">// 1 号窗口</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell03).start(); <span class="hljs-comment">// 2 号窗口</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sell03).start(); <span class="hljs-comment">// 3 号窗口</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 Runnable 接口，使用同步方法 synchronized 实现线程同步</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sell03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 余票</span><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>  <span class="hljs-comment">// 静态同步方法的锁为当前类本身</span><br>  <span class="hljs-comment">// 1. public synchronized static void m1() 的锁是加在 Sell03.class</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// 2. 在静态方法中，实现一个同步代码块</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">synchronized</span> (Sell03.class) &#123; <span class="hljs-comment">// 锁加在当前类本身</span><br>          System.out.println(<span class="hljs-string">&quot;m2&quot;</span>);<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 同步方法，在同一时刻，只能有一个线程来执行</span><br>  <span class="hljs-comment">// 说明：</span><br>  <span class="hljs-comment">// 1. public synchronized boolean sell() &#123;&#125; 是一个同步方法</span><br>  <span class="hljs-comment">// 2. 这时，互斥锁在 this 对象</span><br>  <span class="hljs-comment">// 3. 也可以在代码块上加锁(synchronized)，互斥锁还是在 this 对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-comment">/* synchronized */</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-comment">/* this */</span> object) &#123;<br>          <span class="hljs-keyword">if</span> (ticketNums &lt;= <span class="hljs-number">0</span>) &#123;<br>              System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br><br>          System.out.println(<span class="hljs-string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 售出 1 张，还有 &quot;</span> + --ticketNums + <span class="hljs-string">&quot; 张票&quot;</span>);<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              Thread.sleep(<span class="hljs-number">10</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">while</span> (sell()) &#123;<br>          <span class="hljs-comment">// sell() 方法是同步方法，在同一时刻，只能有一个线程来执行</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>同步方法如果没有使用 <code>static</code> 修饰：默认锁对象为 <code>this</code></li>
<li>如果方法使用 <code>static</code> 修饰，默认锁对象：<code>当前类.class</code></li>
<li>实现的落地步骤：<ol>
<li>先分析上锁的代码</li>
<li>选择同步代码块或同步方法</li>
<li>要求多个线程的锁对象为<strong>同一个</strong></li>
</ol>
</li>
</ol>
<h4 id="争夺互斥锁"><a href="#争夺互斥锁" class="headerlink" title="争夺互斥锁"></a>争夺互斥锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 这里使用 synchronized 实现了线程同步</span><br><span class="hljs-comment">// 2. 当多个线程执行到这里时，就会去争夺 this 对象锁</span><br><span class="hljs-comment">// 3. 哪个线程争夺(获取)到 this 对象锁，就执行 synchronized 代码块</span><br><span class="hljs-comment">// 4. 争夺不到 this 对象锁，就 blocked，准备继续争夺</span><br><span class="hljs-comment">// 5. synchronized 代码块执行完毕后，会释放 this 对象锁</span><br><span class="hljs-comment">// 6. this 对象锁是 非公平锁</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li><p>基本介绍<br> 多个线程都<strong>占用了对方的锁资源</strong>，但不肯想让，导致了死锁，在编程时一定要<strong>避免死锁</strong>的发生</p>
</li>
<li><p>应用案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 模拟死锁现象</span><br>        <span class="hljs-type">DeadLockDemo</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockDemo</span>(<span class="hljs-literal">true</span>);<br>        A.setName(<span class="hljs-string">&quot;A 线程 &quot;</span>);<br>        <span class="hljs-type">DeadLockDemo</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockDemo</span>(<span class="hljs-literal">false</span>);<br>        B.setName(<span class="hljs-string">&quot;B 线程 &quot;</span>);<br>        A.start();<br>        B.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 保证多线程，共享一个对象，这里使用 static</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">boolean</span> flag;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeadLockDemo</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 下面业务逻辑的分析：</span><br><span class="hljs-comment">        * 1. 如果 fLag 为 T，线程 A 就会先得到/持有 o1 对象锁，然后尝试去获取 o2 对象锁</span><br><span class="hljs-comment">        * 2. 如果 线程 A 得不到 o2 对象锁，就会 BLocked</span><br><span class="hljs-comment">        * 3. 如果 fLag 为 F，线程 B 就会先得到/持有 o2 对象锁，然后尝试去获取 o1 对象锁</span><br><span class="hljs-comment">        * 4. 如果 线程 B 得不到 o1 对象锁，就会 BLocked</span><br><span class="hljs-comment">        * 5. 线程 A 得不到 o2 对象锁，线程 B 得不到 o1 对象锁，就会形成死锁</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-keyword">synchronized</span> (o1) &#123; <span class="hljs-comment">// 对象互斥锁，下面就是同步代码</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;进入 1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (o2) &#123; <span class="hljs-comment">// 这里获得 li 对象的监视权限</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;进入 2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (o2) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;进入 3&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (o1) &#123; <span class="hljs-comment">// 这里获得 li 对象的监视权限</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;进入 4&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><ol>
<li><p>下面架作<strong>会</strong>释救锁</p>
<ol>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到 <code>break</code>、<code>return</code></li>
<li>当前线程在同步代码块、同步方法中出现了未处理的 <code>error</code> 或 <code>Exception</code>，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的 <code>wait()</code> 方法，当前线程暂停，并释放锁</li>
</ol>
</li>
<li><p>下面操作<strong>不会</strong>释放锁</p>
<ol>
<li>线程执行同步代码块或同步方法时，程序调用 <code>Thread.sleep()</code>、<code>Thread.yield()</code> 方法暂停当前线程的执行，不会释放锁</li>
<li>线程执行同步代码块时，其他线程调用了该线程的 <code>suspend()</code> 方法将该线程挂起，该线程不会释放锁</li>
<li>提示：应尽量避免使用 <code>suspend()</code> 和 <code>resume()</code> 来控制线程，方法不再推荐使用</li>
</ol>
</li>
</ol>
<h3 id="十六章章课后练习"><a href="#十六章章课后练习" class="headerlink" title="十六章章课后练习"></a>十六章章课后练习</h3><ol>
<li><p>编程题-线程控制</p>
<ol>
<li>在 main() 方法中启动两个线程</li>
<li>第 1 个线程循环随机打印 100 以内的整数</li>
<li>直到第 2 个线程从键盘读取了 <code>Q</code> 命令</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Homework01</span>();<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>(a);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第一个线程，循环打印 1-100 之间的整数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLoop</span><span class="hljs-params">(<span class="hljs-type">boolean</span> loop)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loop = loop;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (loop) &#123;<br>            <span class="hljs-comment">// 输出 1-100 之间的数字</span><br>            System.out.println((<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span> + <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;a 线程已退出&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二个线程，从键盘读取 Q 指令</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(A a)</span> &#123; <span class="hljs-comment">// 构造器中，直接传入 A 类对象</span><br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请输入指令（Q 表示退出）：&quot;</span>);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> scanner.next().toUpperCase().charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 以通知的方式结束 A 线程</span><br>                a.setLoop(<span class="hljs-literal">false</span>);<br>                System.out.println(<span class="hljs-string">&quot;b 线程已退出&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>编程题-互斥锁的争夺</p>
<ol>
<li>有 2 个用户分别从同一个卡上取钱（总额：10000）</li>
<li>每次都取 1000，当余额不足时，则无法取钱</li>
<li>不能出现超取现象 -&gt; 解决线程同步问题<br> <img src="/img/java_learn/mk-2022-06-16-09-55.png" srcset="/img/loading.gif" lazyload alt="思路分析"></li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Card</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>        thread1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>        thread2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 取款线程</span><br><span class="hljs-comment"> * 1. 因为涉及到多个线程共享资源，所以使用实现 Runnable 的方式</span><br><span class="hljs-comment"> * 2. 每次取出 1000</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>            <span class="hljs-comment">// 1. 这里使用 synchronized 实现了线程同步</span><br>            <span class="hljs-comment">// 2. 当多个线程执行到这里时，就会去争夺 this 对象锁</span><br>            <span class="hljs-comment">// 3. 哪个线程争夺(获取)到 this 对象锁，就执行 synchronized 代码块</span><br>            <span class="hljs-comment">// 4. 争夺不到 this 对象锁，就 blocked，准备继续争夺</span><br>            <span class="hljs-comment">// 5. synchronized 代码块执行完毕后，会释放 this 对象锁</span><br>            <span class="hljs-comment">// 6. this 对象锁是 非公平锁</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// this 代表调用当前方法的对象</span><br>                <span class="hljs-comment">// 判断余额是否足够</span><br>                <span class="hljs-keyword">if</span> (balance &lt;= <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;余额不足...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                balance -= <span class="hljs-number">1000</span>;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 取出 1000 元，还剩 &quot;</span> + balance + <span class="hljs-string">&quot;元&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="十七、坦克大战-2"><a href="#十七、坦克大战-2" class="headerlink" title="十七、坦克大战 2"></a>十七、坦克大战 2</h2><ul>
<li><p>坦克大战 0.3</p>
<ul>
<li>分析如何实现当用户按下 <code>J</code> 键，我方坦克发射一颗子弹<br>1. 当发射一颗子弹后，就相当于启动一个线程<br>2. <code>Hero</code> 类有子弹对象，当按下 <code>J</code> 时，就启动一个发射的行为（线程），让子弹不停地移动，形成一个射击的效果<br>3. <code>MyPanel</code> 需要不停地重绘子弹，才能出现该效果<br>4. 当子弹移动到面板的边界时，就应该把启动子弹的线程销毁</li>
</ul>
</li>
<li><p>坦克大战 0.4</p>
<ol>
<li>让敌方的坦克发射子弹（可以有多颗子弹）<ol>
<li>在敌人坦克类，使用 <code>Vector</code> 保存多个 <code>Shot</code></li>
<li>当每创建一个敌人坦克对象，给该敌人坦克对象初始化一个 <code>Shot</code> 对象，同时启动 <code>shot</code></li>
<li>在绘制敌人坦克时，需要变量敌人坦克对象<code>Vector</code>，绘制所有的子弹，当子弹 <code>isLive == false</code> 时，就从 <code>Vector</code> 移除</li>
</ol>
</li>
<li>当我方坦克击中敌人坦克时，敌人的坦克就会消失，爆炸效果</li>
<li>敌方坦克可以自由随机的上下左右移动</li>
<li>控制我方坦克和敌方坦克在规定的范围移动</li>
</ol>
</li>
</ul>
<h2 id="十八、IO-流"><a href="#十八、IO-流" class="headerlink" title="十八、IO 流"></a>十八、IO 流</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h4><p>文件（ File ）是操作系统中的一个重要概念。文件是<strong>保存数据</strong>的地方<br>File 类实现了 <code>Serializable（串行化）</code> 与 <code>Comparable（比较）</code> 接口</p>
<h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>文件在程序中是以流的形式来操作的<br><img src="/img/java_learn/mk-2022-06-17-19-45.png" srcset="/img/loading.gif" lazyload alt="文件流"></p>
<ul>
<li>流：数据在数据源（文件）和程序（内存）之间经历的路径</li>
<li>输入流：数据从数据源（文件）到程序（内存）的路径</li>
<li>输出流：数据从程序（内存）到数据源（文件）的路径</li>
</ul>
<h4 id="文件常用操作"><a href="#文件常用操作" class="headerlink" title="文件常用操作"></a>文件常用操作</h4><ul>
<li><p>文件对象构造器和方法</p>
<ul>
<li><p><code>new File(String pathname)</code>: 根据路径构建一个 <code>File</code> 对象</p>
</li>
<li><p><code>new File(File parent, String child)</code>: 根据<code>父目录文件 + 子路径文件</code>构建</p>
</li>
<li><p><code>new File(String parent, String child)</code>: 根据<code>父目录 + 子路径</code>构建</p>
</li>
<li><p><code>createNewFile</code>: 创建新文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCreate</span> &#123;<br>    <span class="hljs-comment">// 方式 1</span><br>    <span class="hljs-comment">// new File(String pathname): 根据路径构建一个 File 对象</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\news1.txt&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-comment">// 这里的 file 对象，在 Java 程序中，只是一个对象</span><br>        <span class="hljs-comment">// 只有执行了 createNewFile() 方法，才会真正的创建文件</span><br><br>        <span class="hljs-comment">// createNewFile: 创建新文件</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            file.createNewFile();<br>            System.out.println(<span class="hljs-string">&quot;文件创建成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 方式 2</span><br>    <span class="hljs-comment">// new File(File parent, String child): 根据父目录文件 + 子路径文件构建</span><br>    <span class="hljs-comment">// e:\\news2.txt</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create02</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">parentFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;e:\\&quot;</span>); <span class="hljs-comment">// &quot;e:/&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;news2.txt&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentFile, fileName);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            file.createNewFile();<br>            System.out.println(<span class="hljs-string">&quot;文件创建成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// new File(String parent, String child): 根据父目录 + 子路径构建</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create03</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">parentPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\&quot;</span>; <span class="hljs-comment">// &quot;e:/&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;news3.txt&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentPath, fileName);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            file.createNewFile();<br>            System.out.println(<span class="hljs-string">&quot;文件创建成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>获取文件的相关信息</p>
<ul>
<li><p><code>getName()</code>: 获取文件名</p>
</li>
<li><p><code>getAbsolutePath()</code>: 获取文件绝对路径</p>
</li>
<li><p><code>getParent()</code>: 获取文件父级目录</p>
</li>
<li><p><code>length()</code>: 获取文件大小（字节）</p>
</li>
<li><p><code>exists()</code>: 判断该路径名表示的文件或目录是否存在</p>
</li>
<li><p><code>isFile()</code>: 判断该路径指定的文件是否为一个标准文件</p>
</li>
<li><p><code>isDirectory()</code>: 判断该路径指定的文件是否为一个目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInformation</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建文件对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;e:\\news1.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 调用相应的方法，得到对应信息</span><br>        <span class="hljs-comment">// getName、getAbsolutePath、getParent、Length、exists、isFile、isDirectory</span><br>        System.out.println(<span class="hljs-string">&quot;文件名=&quot;</span> + file.getName());<br>        System.out.println(<span class="hljs-string">&quot;文件绝对路径=&quot;</span> + file.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;文件父级目录=&quot;</span> + file.getParent());<br>        System.out.println(<span class="hljs-string">&quot;文件大小(字节)=&quot;</span> + file.length()); <span class="hljs-comment">// 英文 = 1 字节；汉字 = 3 字节</span><br>        System.out.println(<span class="hljs-string">&quot;文件是否存在=&quot;</span> + file.exists());<br>        System.out.println(<span class="hljs-string">&quot;是不是一个文件=&quot;</span> + file.isFile());<br>        System.out.println(<span class="hljs-string">&quot;是不是一个目录=&quot;</span> + file.isDirectory());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>目录的操作和文件删除</p>
<ul>
<li><p><code>mkdir()</code>: 创建一级目录，返回 <code>boolean</code></p>
</li>
<li><p><code>mkdirs()</code>: 创建多级目录，返回 <code>boolean</code></p>
</li>
<li><p><code>delete()</code>: 删除空目录或文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> &#123;<br>    <span class="hljs-comment">// // 判断文件是否存在，存在就删除，否则提示不存在</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\news1.txt&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            <span class="hljs-keyword">if</span> (file.delete()) &#123;<br>                System.out.println(filePath + <span class="hljs-string">&quot; 删除成功&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(filePath + <span class="hljs-string">&quot; 删除失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;该文件不存在...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断目录是否存在，存在就删除，否则提示不存在</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">directoryPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\demo02&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(directoryPath);<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            <span class="hljs-keyword">if</span> (file.delete()) &#123;<br>                System.out.println(directoryPath + <span class="hljs-string">&quot; 删除成功&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(directoryPath + <span class="hljs-string">&quot; 删除失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;该目录不存在...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 E:\\demo\\a\\b\\c 目录是否存在，如果存在就提示已存在，否则创建该目录</span><br>    <span class="hljs-comment">// 创建一级目录使用 mkdir()，创建多级目录使用 mkdirs()</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">directoryPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E:\\demo\\a\\b\\c&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(directoryPath);<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            System.out.println(directoryPath + <span class="hljs-string">&quot; 已经存在..&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (file.mkdirs()) &#123;<br>                System.out.println(directoryPath + <span class="hljs-string">&quot; 创建成功&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(directoryPath + <span class="hljs-string">&quot; 创建失败&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h3><h4 id="Java-IO-流原理"><a href="#Java-IO-流原理" class="headerlink" title="Java IO 流原理"></a>Java IO 流原理</h4><ol>
<li><code>I/O</code> 是 <code>Input/Output</code> 的缩写，<code>I/O</code> 技术是非常实用的技术，用于处理数据传输。如读&#x2F;写文件，网络通讯等</li>
<li>Java 程序中，对于数据的输入&#x2F;输出操作以 <code>流(stream)</code> 的方式进行</li>
<li><code>java.io</code> 包下提供了各种「流」类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li>
<li>输入 <code>input</code>: 读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中</li>
<li>输出 <code>output</code>: 将程序（内存）数据输出到硬盘、光盘等存储设备中</li>
</ol>
<h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ol>
<li>按操作数据单位不同分为：字节流 (8 bit)【二进制文件】，字符流【文本文件】</li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色的不同分为：节点流，处理流&#x2F;包装流</li>
</ol>
<table>
<thead>
<tr>
<th align="center">（抽象基类）</th>
<th align="center">字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节&#x2F;字符 输入流</td>
<td align="center">InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td align="center">字节&#x2F;字符 输出流</td>
<td align="center">OutputStream</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li>Java 的 IO 流共涉及 40 多个类，实际上非常规则，都是从如上 4 个<strong>抽象基类</strong>派生的</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</li>
</ol>
<h4 id="IO-流体系图"><a href="#IO-流体系图" class="headerlink" title="IO 流体系图"></a>IO 流体系图</h4><p><img src="/img/java_learn/mk-2022-06-19-12-20.png" srcset="/img/loading.gif" lazyload alt="IO 流体系图"></p>
<h3 id="InputStream-字节输入流"><a href="#InputStream-字节输入流" class="headerlink" title="InputStream 字节输入流"></a>InputStream 字节输入流</h3><p>InputStream 类图<br><img src="/img/java_learn/mk-2022-06-19-13-22.png" srcset="/img/loading.gif" lazyload alt="InputStream 类图"></p>
<h3 id="文件节点流-File"><a href="#文件节点流-File" class="headerlink" title="文件节点流 File"></a>文件节点流 File</h3><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><ol>
<li><p>基本介绍</p>
<ul>
<li><code>FileInputStream</code>: 文件输入流</li>
<li>继承类：<ul>
<li><code>InputStream</code><ul>
<li><code>FileInputStream</code></li>
</ul>
</li>
</ul>
</li>
<li>实现接口：<ul>
<li><code>Closeable</code></li>
</ul>
</li>
</ul>
</li>
<li><p>构造器与方法（Java API 1.6）</p>
<ul>
<li><p>构造器</p>
<ul>
<li><code>FileInputStream(File file)</code>: 通过打开一个到实际文件的连接来创建一个 <code>FileInputStream</code>，该文件通过文件系统中的 <code>File</code> 对象 <code>file</code> 指定</li>
<li><code>FileInputStream(FileDescriptor fdObj)</code>: 通过使用文件描述符 <code>fdObj</code> 创建一个 <code>FileInputStream</code>，该文件描述符表示到文件系统中某个实际文件的现有连接</li>
<li><strong><code>FileInputStream(String name)</code>: 通过打开一个到实际文件的连接来创建一个 <code>FileInputStream</code>，该文件通过文件系统中的路径名 <code>name</code> 指定</strong></li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><code>int available()</code>: 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数</li>
<li><strong><code>void close()</code>: 关闭此文件输入流并释放与此流有关的所有系统资源</strong></li>
<li><code>protected  void finalize()</code>: 确保在不再引用文件输入流时调用其 <code>close</code> 方法</li>
<li><code>FileChannel getChannel()</code>: 返回与此文件输入流有关的唯一 <code>FileChannel</code> 对象</li>
<li><code>FileDescriptor getFD()</code>: 返回表示到文件系统中实际文件的连接的 <code>FileDescriptor</code> 对象，该文件系统正被此 <code>FileInputStream</code> 使用</li>
<li><strong><code>int read()</code>: 从此输入流中读取一个数据字节，返回读取的数据字节，如果返回 <code>-1</code>，表示读取完毕</strong></li>
<li><strong><code>int read(byte[] b)</code>: 从此输入流中将最多 <code>b.length</code> 个字节的数据读入一个 <code>byte</code> 数组中，如果读取正常，返回实际读取的字节数，如果返回 <code>-1</code>，表示读取完毕</strong></li>
<li><strong><code>int read(byte[] b, int off, int len)</code>: 从此输入流中将最多 <code>len</code> 个字节的数据读入一个 <code>byte</code> 数组中</strong></li>
<li><code>long skip(long n)</code>: 从输入流中跳过并丢弃 <code>n</code> 个字节的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>应用实例</p>
<ul>
<li>使用 <code>FileInputStream</code> 读取 <code>hello.txt</code> 文件，并将文件内容显示到控制台</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 FileInputStream 的使用（字节输入流 文件 --&gt; 程序）</span><br><span class="hljs-comment"> * 使用 FileInputStream 读取 hello.txt 文件，并将文件内容显示到控制台</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStream_</span> &#123;<br><br>    <span class="hljs-comment">// 单个字节读取，效率较低</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\hello.txt&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readDate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建 FileInputStream 对象，用于读取文件</span><br>            fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br><br>            <span class="hljs-comment">// read(): 从此输入流中读取一个数据字节</span><br>            <span class="hljs-comment">// 如果读取正常，返回读取的数据字节 (int)</span><br>            <span class="hljs-comment">// 如果返回 -1，表示读取完毕</span><br>            <span class="hljs-keyword">while</span> ((readDate = fileInputStream.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) readDate); <span class="hljs-comment">// 转成 char</span><br>            &#125;<br>            <span class="hljs-comment">// 关闭文件流，释放资源</span><br>            fileInputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 read(byte[] b) 读取文件，提高效率</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile02</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\hello.txt&quot;</span>;<br>        <span class="hljs-comment">// 创建 byte[] 数组</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>]; <span class="hljs-comment">// 一次读取 8 个字节</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建 FileInputStream 对象，用于读取文件</span><br>            fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br><br>            <span class="hljs-comment">// read(byte[] b): 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中</span><br>            <span class="hljs-comment">// 如果读取正常，返回实际读取的字节数</span><br>            <span class="hljs-comment">// 如果返回 -1，表示读取完毕</span><br>            <span class="hljs-keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen)); <span class="hljs-comment">// 转成 String</span><br>            &#125;<br>            <span class="hljs-comment">// 关闭文件流，释放资源</span><br>            fileInputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><ol>
<li><p>基本介绍<br> <code>FileOutputStream</code>: 文件输出流</p>
<ul>
<li>继承类：<ul>
<li><code>InputStream</code><ul>
<li><code>FileOutputStream</code></li>
</ul>
</li>
</ul>
</li>
<li>实现接口：<ul>
<li><code>Closeable</code></li>
<li><code>Flushable</code></li>
</ul>
</li>
</ul>
</li>
<li><p>构造器与方法（Java API 1.6）</p>
<ul>
<li><p>构造器</p>
<ul>
<li><code>FileOutputStream(File file)</code>: 创建一个向指定 <code>File</code> 对象表示的文件中写入数据的文件输出流</li>
<li><code>FileOutputStream(File file, boolean append)</code>: 创建一个向指定 <code>File</code> 对象表示的文件中写入数据的文件输出流</li>
<li><code>FileOutputStream(FileDescriptor fdObj)</code>: 创建一个向指定文件描述符处写入数据的输出文件流，该文件描述符表示一个到文件系统中的某个实际文件的现有连接</li>
<li><strong><code>FileOutputStream(String name)</code>: 创建一个向具有指定名称的文件中写入数据的输出文件流</strong></li>
<li><strong><code>FileOutputStream(String name, boolean append)</code>: 创建一个向具有指定 <code>name</code> 的文件中写入数据的输出文件流</strong></li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><strong><code>void close()</code>: 关闭此文件输出流并释放与此流有关的所有系统资源</strong></li>
<li><code>protected  void finalize()</code>: 清理到文件的连接，并确保在不再引用此文件输出流时调用此流的 <code>close</code> 方法</li>
<li><code>FileChannel getChannel()</code>: 返回与此文件输出流有关的唯一 <code>FileChannel</code> 对象</li>
<li><code>FileDescriptor getFD()</code>: 返回与此流有关的文件描述符</li>
<li><strong><code>void write(byte[] b)</code>: 将 <code>b.length</code> 个字节从指定 <code>byte</code> 数组写入此文件输出流中</strong></li>
<li><strong><code>void write(byte[] b, int off, int len)</code>: 将指定 <code>byte</code> 数组中从偏移量 <code>off</code> 开始的 <code>len</code> 个字节写入此文件输出流</strong></li>
<li><strong><code>void write(int b)</code>: 将指定字节写入此文件输出流</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>应用实例</p>
<ol>
<li><p>使用 <code>FileOutputStream</code> 在 <code>a.txt</code> 文件中写入 <code>hello, world</code>，如果文件不存在，则自动创建文件</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 演示 FileOutputStream 的使用</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputStream_</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 将数据写入到文件中</span><br><span class="hljs-comment">    * 如果该文件不存在，则自动创建文件</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeFile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建 FileOutputStream</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\a.txt&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 得到 FileOutputStream 对象</span><br>            <span class="hljs-comment">// 说明：</span><br>            <span class="hljs-comment">// 1. new FileOutputStream(filePath) 创建方式，当写入内容时，会覆盖原来的内容</span><br>            <span class="hljs-comment">// 2. new FileOutputStream(filePath, true) 创建方式，当写入内容时，会追加到文件最后</span><br>            fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br><br>            <span class="hljs-comment">// 写入一个字节</span><br>            <span class="hljs-comment">// void write(int b): 将指定字节写入此文件输出流</span><br>            fileOutputStream.write(<span class="hljs-string">&#x27;a&#x27;</span>);<br><br>            <span class="hljs-comment">// 写入字符串 / 字节数组</span><br>            <span class="hljs-comment">// void write(byte[] b): 将 b.length 个字节从指定 byte 数组写入此文件输出流中</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, world &quot;</span>;<br>            <span class="hljs-comment">// str.getBytes(): 把字符串转为字节数组</span><br>            fileOutputStream.write(str.getBytes());<br><br>            <span class="hljs-comment">// 写入字节数组并指定位置与长度</span><br>            <span class="hljs-comment">// void write(byte[] b, int off, int len): 将指定`byte 数组中从偏移量 off 开始的 len</span><br>            <span class="hljs-comment">// 个字节写入此文件输出流</span><br>            fileOutputStream.write(str.getBytes(), <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br><br>            fileOutputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>完成 图片&#x2F;音乐 的拷贝</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileCopy</span>().copy();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 完成文件的拷贝</span><br><span class="hljs-comment">     * 1. 创建文件的输入流，将文件读入到程序</span><br><span class="hljs-comment">     * 2. 创建文件的输出流，将读取到的文件数据，写入到指定的文件</span><br><span class="hljs-comment">     * 3. 循环拷贝部分数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePathSrc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\demo\\a\\1.jpg&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePathDest</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\demo\\b\\1.jpg&quot;</span>;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 创建字节数组</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建流对象</span><br>            fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePathSrc);<br>            fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePathDest);<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 拷贝</span><br>            <span class="hljs-keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 读取到后写入文件</span><br>                <span class="hljs-comment">// 一定使用这个方法写入文件，否则可能出现文件损失</span><br>                fileOutputStream.write(buf, <span class="hljs-number">0</span>, readLen);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;拷贝成功！&quot;</span>);<br><br>            <span class="hljs-comment">// 关闭文件流，释放资源</span><br>            fileInputStream.close();<br>            fileOutputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><ol>
<li><p>基本介绍</p>
<ul>
<li><code>FileReader</code>: 字符流，即按照字符来操作 IO</li>
<li>继承类：<ul>
<li><code>Reader</code><ul>
<li><code>InputStreamReader</code><ul>
<li><code>FileReader</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实现接口：<ul>
<li><code>Closeable</code></li>
<li><code>Readable</code></li>
</ul>
</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><code>new FileReader(File/String)</code>: 在给定从中读取数据的 <code>File/文件名</code> 的情况下创建一个新 <code>FileReader</code></li>
<li><code>read</code>: 每次读取单个字符，返回该字符，如果到文件末尾返回 <code>-1</code></li>
<li><code>read(char[])</code>: 批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回 <code>-1</code></li>
<li>相关 API<ul>
<li><code>new String(char[])</code>: 将 <code>char[]</code> 转换成 <code>String</code></li>
<li><code>new String(char[], off, len)</code>: 将 <code>char[]</code> 的指定部分转换成 <code>String</code></li>
</ul>
</li>
</ul>
</li>
<li><p>应用案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader_</span> &#123;<br><br>    <span class="hljs-comment">// read() 单个字符读取</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\story.txt&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readDate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            file.createNewFile(); <span class="hljs-comment">// 创建文件</span><br>            fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file); <span class="hljs-comment">// 创建 FileReader 对象</span><br>            <span class="hljs-comment">// 单个读取数据并遍历输出</span><br>            <span class="hljs-keyword">while</span> ((readDate = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) readDate); <span class="hljs-comment">// 转换为 char</span><br>            &#125;<br><br>            fileReader.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// read(char[]) 使用字符数组批量读取多个字符</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile02</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\story.txt&quot;</span>;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">char</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 读取到的字符长度</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath); <span class="hljs-comment">// 创建 FileReader 对象</span><br>            <span class="hljs-comment">// 单个读取数据并遍历输出</span><br>            <span class="hljs-keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen)); <span class="hljs-comment">// 输出读取到的内容</span><br>            &#125;<br><br>            fileReader.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><ol>
<li><p>基本介绍</p>
<ul>
<li><code>FileWriter</code>: 字符流，即按照字符来操作 IO</li>
<li>继承类：<ul>
<li><code>Writer</code><ul>
<li><code>OutputStreamWriter</code><ul>
<li><code>FileWriter</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实现接口：<ul>
<li><code>Closeable</code></li>
<li><code>Flushable</code></li>
<li><code>Appendable</code></li>
</ul>
</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><code>new FileWriter(File/String)</code>: 覆盖模式，相当于流的指针在首端</li>
<li><code>new FileWriter(File/String, true)</code>: 追加模式，相当于流的指针在尾端</li>
<li><code>write(int)</code>: 写入单个字符</li>
<li><code>write(char[])</code>: 写入指定数组</li>
<li><code>write(char[], off, len)</code>: 写入指定数组的指定部分</li>
<li><code>write(String)</code>: 写入整个字符串</li>
<li><code>write(String, off, len)</code>: 写入字符串的指定部分</li>
<li>相关 API<ul>
<li><code>toCharArray</code>: 将 <code>String</code> 转换成 <code>char[]</code></li>
</ul>
</li>
<li><strong>注意：</strong><br> <code>FileWriter</code> 使用后，必须要<strong>关闭（close）</strong>或<strong>刷新（flush）</strong>，否则写入不到指定的文件</li>
</ul>
</li>
<li><p>应用案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriter_</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writerFile01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\note.txt&quot;</span>;<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;风雨之后，定见彩虹&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 覆盖模式，覆盖该文件之前的内容</span><br>            fileWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath);<br><br>            <span class="hljs-comment">// write(int): 写入单个字符</span><br>            fileWriter.write(<span class="hljs-string">&quot;写入单个字符：\n&quot;</span>);<br>            fileWriter.write(<span class="hljs-string">&#x27;C&#x27;</span>);<br><br>            <span class="hljs-comment">// write(char[]): 写入指定数组</span><br>            fileWriter.write(<span class="hljs-string">&quot;\n\n写入指定数组：\n&quot;</span>);<br>            fileWriter.write(str.toCharArray());<br><br>            <span class="hljs-comment">// write(char[], off, len): 写入指定数组的指定部分</span><br>            fileWriter.write(<span class="hljs-string">&quot;\n\n写入指定数组的指定部分：\n&quot;</span>);<br>            fileWriter.write(str.toCharArray(), <span class="hljs-number">0</span>, str.length());<br><br>            <span class="hljs-comment">// write(String): 写入整个字符串</span><br>            fileWriter.write(<span class="hljs-string">&quot;\n\n写入整个字符串：\n&quot;</span>);<br>            fileWriter.write(str);<br><br>            <span class="hljs-comment">// write(String, off, len): 写入字符串的指定部分</span><br>            fileWriter.write(<span class="hljs-string">&quot;\n\n写入字符串的指定部分：\n&quot;</span>);<br>            fileWriter.write(str, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// fileWriter.flush(); // 刷新文件</span><br>            fileWriter.close(); <span class="hljs-comment">// 刷新 + 关闭</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="节点流和处理流（重点）"><a href="#节点流和处理流（重点）" class="headerlink" title="节点流和处理流（重点）"></a>节点流和处理流（重点）</h3><h4 id="节点流和处理流基本介绍"><a href="#节点流和处理流基本介绍" class="headerlink" title="节点流和处理流基本介绍"></a>节点流和处理流基本介绍</h4><ol>
<li>节点流可以从一个特定的数据源<strong>读写数据</strong>，如 <code>FileReader</code>、<code>FileWriter</code><br> <img src="/img/java_learn/mk-2022-06-20-13-15.png" srcset="/img/loading.gif" lazyload alt="节点流"></li>
<li>处理流（也叫<strong>包装流</strong>）是「连接」在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活，如 <code>BufferedReader</code>、<code>BufferedWriter</code><br> <img src="/img/java_learn/mk-2022-06-20-13-16.png" srcset="/img/loading.gif" lazyload alt="处理流"></li>
<li>比如 <code>BufferedReader</code> 类中，有属性 <code>Reader</code>，可以封装任何继承了 <code>Reader</code> 的节点流<br> <img src="/img/java_learn/mk-2022-06-20-13-37.png" srcset="/img/loading.gif" lazyload alt="处理流的功能"></li>
</ol>
<h4 id="节点流和处理流一览图"><a href="#节点流和处理流一览图" class="headerlink" title="节点流和处理流一览图"></a>节点流和处理流一览图</h4><p><img src="/img/java_learn/mk-2022-06-20-13-18.png" srcset="/img/loading.gif" lazyload alt="节点流和处理流一览图"></p>
<h4 id="节点流和处理流的区别和联系"><a href="#节点流和处理流的区别和联系" class="headerlink" title="节点流和处理流的区别和联系"></a>节点流和处理流的区别和联系</h4><ol>
<li><p>节点流和处理流的区别和联系</p>
<ol>
<li>节点流是底层流&#x2F;低级流，直接跟数据源相接</li>
<li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li>
<li>处理流（包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li>
</ol>
</li>
<li><p>处理流的功能</p>
<ol>
<li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li>
<li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</li>
</ol>
</li>
<li><p>模拟修饰器设计模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorDesignPattern</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 通过 BufferedReader_ 多次读取文件</span><br>        <span class="hljs-type">BufferedReader_</span> <span class="hljs-variable">bufferedReader_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader_</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader_</span>());<br>        <span class="hljs-comment">// bufferedReader_.readFile();</span><br>        bufferedReader_.readFiles(<span class="hljs-number">5</span>); <br><br>        <span class="hljs-comment">// 通过 BufferedReader_ 多次读取文件</span><br>        <span class="hljs-type">BufferedReader_</span> <span class="hljs-variable">bufferedReader_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader_</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader_</span>());<br>        <span class="hljs-comment">// bufferedReader_2.readString();</span><br>        bufferedReader_2.readStrings(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader_</span> &#123; <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readString</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 节点流</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;对文件进行读取...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 节点流</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readString</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取字符串...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理流 / 包装流</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-keyword">private</span> Reader_ reader_;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedReader_</span><span class="hljs-params">(Reader_ reader_)</span> &#123;<br>        <span class="hljs-built_in">this</span>.reader_ = reader_;<br>    &#125;<br><br>    <span class="hljs-comment">// 封装</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> &#123;<br>        reader_.readFile();<br>    &#125;<br><br>    <span class="hljs-comment">// 封装</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readString</span><span class="hljs-params">()</span> &#123;<br>        reader_.readString();<br>    &#125;<br><br>    <span class="hljs-comment">// 让方法更加灵活，多次读取文件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFiles</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            reader_.readFile();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 扩展 readString, 批量处理字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readStrings</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            reader_.readString();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 模拟修饰器设计模式 优化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 通过 BufferedReader_ 多次读取文件</span><br>        <span class="hljs-type">BufferedReader_</span> <span class="hljs-variable">bufferedReader_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader_</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader_</span>());<br>        bufferedReader_.read();<br>        bufferedReader_.read(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 通过 BufferedReader_ 多次读取文件</span><br>        <span class="hljs-type">BufferedReader_</span> <span class="hljs-variable">bufferedReader_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader_</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader_</span>());<br>        bufferedReader_2.read();<br>        bufferedReader_2.read(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader_</span> &#123; <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// public void readFile() &#123;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// public void readString() &#123;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 在 Reader_ 抽象类，也可以使用 read() 方法统一管理</span><br>    <span class="hljs-comment">// 后面在调用时，利用对象的动态绑定机制，绑定对应的实现子类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 节点流</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;对文件进行读取...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 节点流</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;对字符串进行读取...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理流 / 包装流</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-keyword">private</span> Reader_ reader_;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedReader_</span><span class="hljs-params">(Reader_ reader_)</span> &#123;<br>        <span class="hljs-built_in">this</span>.reader_ = reader_;<br>    &#125;<br><br>    <span class="hljs-comment">// 封装</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        reader_.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 让方法更加灵活，多次读取文件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            reader_.read();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><ol>
<li><p>基本介绍</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类型</th>
<th align="center">默认设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>System.in</code> 标准输入</td>
<td align="center"><code>InputStream</code></td>
<td align="center">键盘</td>
</tr>
<tr>
<td align="center"><code>System.out</code> 标准输出</td>
<td align="center"><code>PrintStream</code></td>
<td align="center">显示器</td>
</tr>
</tbody></table>
</li>
<li><p>应用案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputAndOutput</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// System 类的 public final static InputStream in = null;</span><br>        <span class="hljs-comment">// System.in 编译类型 : InputStream</span><br>        <span class="hljs-comment">// System.in 运行类型 : BufferedInputStream</span><br>        <span class="hljs-comment">// 表示标准输入 键盘</span><br>        System.out.println(System.in.getClass());<br><br>        <span class="hljs-comment">// System 类的 public static final PrintStream out = null;</span><br>        <span class="hljs-comment">// System.out 编译类型 : PrintStream</span><br>        <span class="hljs-comment">// System.out 运行类型 : PrintStream</span><br>        <span class="hljs-comment">// 表示标准输出 显示器</span><br>        System.out.println(System.out.getClass());<br><br>        System.out.println(<span class="hljs-string">&quot;hello, world&quot;</span>);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;输入内容：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> scanner.next();<br>        System.out.println(<span class="hljs-string">&quot;next=&quot;</span> + next);<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="缓冲处理流-Buffered"><a href="#缓冲处理流-Buffered" class="headerlink" title="缓冲处理流 Buffered"></a>缓冲处理流 Buffered</h3><h4 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h4><ol>
<li><p>基本介绍</p>
<ol>
<li><code>BufferedReader</code> 属于<strong>处理流</strong></li>
<li><code>BufferedReader</code> 属于<strong>字符流</strong>，是按照字符来读取数据的，继承 <code>Reader</code> 类</li>
<li><code>BufferedReader</code> 关闭<strong>处理流</strong>时，只需要关闭外层流即可</li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>BufferedReader(Reader in)</code>: 创建一个使用默认大小输入缓冲区的缓冲字符输入流</li>
<li><code>BufferedReader(Reader in, int sz)</code>: 创建一个使用指定大小输入缓冲区的缓冲字符输入流</li>
<li><code>void close()</code>: 关闭该流并释放与之关联的所有资源</li>
<li><code>void mark(int readAheadLimit)</code>: 标记流中的当前位置</li>
<li><code>boolean markSupported()</code>: 判断此流是否支持 <code>mark()</code> 操作（它一定支持）</li>
<li><code>int read()</code>: 读取单个字符，返回读取到的字符，如果已达到流末尾，返回 <code>-1</code></li>
<li><code>int read(char[] cbuf, int off, int len)</code>: 将字符读入数组的某一部分</li>
<li><code>String readLine()</code>: 读取一个文本行，没有换行，返回读取到的字符串，如果读取到流末尾，返回 <code>null</code></li>
<li><code>boolean ready()</code>: 判断此流是否已准备好被读取</li>
<li><code>void reset()</code>: 将流重置到最新的标</li>
<li><code>long skip(long n)</code>: 跳过字符</li>
</ul>
</li>
<li><p>应用案例<br> 使用 <code>BufferedReader</code> 读取文本文件，并显示在控制台</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReader_</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\story.txt&quot;</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        String line; <span class="hljs-comment">// 按行读取，效率高</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            bufferedReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath));<br>            <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(line);<br>            &#125;<br><br>            <span class="hljs-comment">// 关闭流，只需要关闭 BufferedReader 即可，底层会自动关闭节点流 FileReader</span><br>            bufferedReader.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h4><ol>
<li><p>基本介绍</p>
<ol>
<li><code>BufferedWriter</code> 属于<strong>处理流</strong></li>
<li><code>BufferedWriter</code> 属于<strong>字符流</strong>，是按照字符来读取数据的，继承 <code>Writer</code> 类</li>
<li><code>BufferedWriter</code> 关闭<strong>处理流</strong>时，只需要关闭外层流即可</li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>BufferedWriter(Writer out)</code>: 创建一个使用默认大小输出缓冲区的缓冲字符输出流</li>
<li><code>BufferedWriter(Writer out, int sz)</code>: 创建一个使用给定大小输出缓冲区的新缓冲字符输出流</li>
<li><code>void close()</code>: 关闭此流，但要先刷新它</li>
<li><code>void flush()</code>: 刷新该流的缓冲</li>
<li><code>void newLine()</code>: 写入一个行分隔符</li>
<li><code>void write(char[] cbuf, int off, int len)</code>: 写入字符数组的某一部分</li>
<li><code>void write(int c)</code>: 写入单个字符</li>
<li><code>void write(String s, int off, int len)</code>: 写入字符串的某一部分</li>
</ul>
</li>
<li><p>应用案例</p>
<ul>
<li><p>使用 <code>BufferedWriter</code> 将 <code>hello, world</code> 写入到文件中</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedWriter_</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\hello.txt&quot;</span>;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 覆盖模式</span><br>            bufferedWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath<span class="hljs-comment">/* , true */</span>));<br>            <span class="hljs-comment">// 写入字符串</span><br>            bufferedWriter.write(<span class="hljs-string">&quot;hello, world&quot;</span>);<br><br>            <span class="hljs-comment">// 写入一个和系统相关的换行符</span><br>            bufferedWriter.newLine();<br><br>            <span class="hljs-comment">// 写入字符串</span><br>            bufferedWriter.write(<span class="hljs-string">&quot;hello, Java&quot;</span>);<br><br>            bufferedWriter.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>综合使用 <code>BufferedReader</code> 和 <code>BufferedWriter</code> 完成文本文件拷贝</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopy</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileCopy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// BufferedReader 和 BufferedWriter 是按照字符操作</span><br>        <span class="hljs-comment">// 不要去操作二进制文件[音频、视频、图片等]，否则可能造成文件损坏</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePathSrc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\story.txt&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePathDest</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\story2.txt&quot;</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        String line; <span class="hljs-comment">// 按行读取</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePathSrc));<br>            bw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePathDest));<br><br>            <span class="hljs-comment">// readLine: 读取一行内容，但是没有换行</span><br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 每读取一行，就写入</span><br>                bw.write(line);<br>                <span class="hljs-comment">// 插入换行</span><br>                bw.newLine();<br>            &#125;<br><br>            br.close();<br>            bw.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;拷贝完毕&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h4><ol>
<li><p>基本介绍</p>
<ol>
<li>继承类<ul>
<li><code>java.io.InputStream</code><ul>
<li><code>java.io.FilterInputStream</code><ul>
<li><code>java.io.BufferedInputStream</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>BufferedInputStream</code> 是<strong>字节流</strong>，在创建 <code>BufferedInputStream</code> 时，会创建一个内部缓冲区数组</li>
<li>BufferedInputStream 类图<br> <img src="/img/java_learn/mk-2022-06-21-13-01.png" srcset="/img/loading.gif" lazyload alt="BufferedInputStream 类图"></li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>BufferedInputStream(InputStream in)</code>: 创建一个 <code>BufferedInputStream</code> 并保存其参数，即输入流 <code>in</code>，以便将来使用</li>
<li><code>BufferedInputStream(InputStream in, int size)</code>: 创建具有指定缓冲区大小的 <code>BufferedInputStream</code> 并保存其参数，即输入流 <code>in</code>，以便将来使用</li>
<li><code>int available()</code>: 返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数</li>
<li><code>void close()</code>: 关闭此输入流并释放与该流关联的所有系统资源</li>
<li><code>void mark(int readlimit)</code>: 在此输入流中标记当前的位置</li>
<li><code>boolean markSupported()</code>: 测试此输入流是否支持 <code>mark</code> 和 <code>reset</code> 方法</li>
<li><code>int read()</code>: 从输入流中读取数据的下一个字节</li>
<li><code>int read(byte[] b)</code>: 从此输入流中将最多 <code>b.length</code> 个字节的数据读入一个 <code>byte</code> 数组中，如果读取正常，返回实际读取的字节数，如果返回 <code>-1</code>，表示读取完毕</li>
<li><code>int read(byte[] b, int off, int len)</code>: 从此字节输入流中给定偏移量处开始将各字节读取到指定的 <code>byte</code> 数组中</li>
<li><code>byte[] readAllBytes()</code>: 从输入流中读取所有剩余字节</li>
<li><code>int readNBytes(byte[] b, int off, int len)</code>: 从输入流中读取要求的字节数到给定的字节数组</li>
<li><code>byte[] readNBytes(int len)</code>: 从输入流中最多读取指定数量的字节</li>
<li><code>void reset()</code>: 将此流重新定位到最后一次对此输入流调用 <code>mark</code> 方法时的位置</li>
<li><code>long skip(long n)</code>: 跳过和丢弃此输入流中数据的 <code>n</code> 个字节</li>
</ul>
</li>
</ol>
<h4 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h4><ol>
<li><p>基本介绍</p>
<ol>
<li>继承类<ul>
<li><code>java.io.OutputStream</code><ul>
<li><code>java.io.FilterOutputStream</code><ul>
<li><code>java.io.BufferedOutputStream</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>BufferedOutputStream</code> 是<strong>字节流</strong>，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统</li>
<li>BufferedOutputStream 类图<br> <img src="/img/java_learn/mk-2022-06-21-12-59.png" srcset="/img/loading.gif" lazyload alt="BufferedOutputStream 类图"></li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>BufferedOutputStream(OutputStream out)</code>: 创建一个新的缓冲输出流，以将数据写入指定的底层输出流</li>
<li><code>BufferedOutputStream(OutputStream out, int size)</code>: 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流</li>
<li><code>void flush()</code>: 刷新此缓冲的输出流</li>
<li><code>void write(byte[] b, int off, int len)</code>: 将指定 byte 数组中从偏移量 <code>off</code> 开始的 <code>len</code> 个字节写入此缓冲的输出流</li>
<li><code>void write(int b)</code>: 将指定的字节写入此缓冲的输出流</li>
</ul>
</li>
<li><p>应用案例<br> 编程完成 图片&#x2F;音乐 的拷贝（使用 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedCopy02</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePathSrc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\demo\\a\\1.jpg&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePathDest</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\demo\\b\\1.jpg&quot;</span>;<br><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePathSrc));<br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePathDest));<br>            <span class="hljs-keyword">while</span> ((readLen = bis.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(buf, <span class="hljs-number">0</span>, readLen);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bis != <span class="hljs-literal">null</span>)<br>                bis.close();<br>            <span class="hljs-keyword">if</span> (bos != <span class="hljs-literal">null</span>)<br>                bos.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;拷贝完成！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="对象处理流-Object"><a href="#对象处理流-Object" class="headerlink" title="对象处理流 Object"></a>对象处理流 Object</h3><h4 id="对象处理流介绍"><a href="#对象处理流介绍" class="headerlink" title="对象处理流介绍"></a>对象处理流介绍</h4><ol>
<li><p>引出对象处理流-看一个需求</p>
<ol>
<li>将 <code>int num = 100</code> 这个 <code>int</code> 数据保存到文件中，注意不是 <code>100</code> 数字，而是 <code>int 100</code>，并且，能够从文件中直接恢复 <code>int 100</code></li>
<li>将 <code>Dog dog = new Dog(&quot;小黄&quot;, 3)</code>这个 <code>dog</code> 对像保存到文件中，并且能够从文件恢复</li>
<li>上面的要求，就是能够将<strong>基本数据类型</strong>或者<strong>对象</strong>进行<strong>序列化</strong>和<strong>反序列化</strong>操作</li>
</ol>
</li>
<li><p>序列化和反序列化</p>
<ol>
<li><strong>序列化</strong>（<code>ObjectOutputStream</code>）就是在保存数据时，保存<strong>数据的值</strong>和<strong>数据类型</strong></li>
<li><strong>反序列化</strong>（<code>ObjectInputStream</code>）就是在恢复数据时，恢复<strong>数据的值</strong>和<strong>数据类型</strong></li>
<li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：<ul>
<li><code>Serializable</code>: 这是一个标记接口，没有方法，推荐使用</li>
<li><code>Externalizable</code>: 这个接口有方法需要实现，因此一般实现上面的 <code>Serializable</code> 接口</li>
</ul>
</li>
</ol>
</li>
<li><p>对象处理流注意事项</p>
<ol>
<li><p><strong>读写顺序要一致</strong></p>
</li>
<li><p>要求实现<strong>序列化</strong>或<strong>反序列化</strong>对像，需要实现 <code>Serializable</code></p>
</li>
<li><p>序列化的类中建议添加 <code>SerialVersionUID</code>，为了提高版本的兼容性</p>
</li>
<li><p>序列化对象时，默认将里面<strong>所有属性</strong>都进行序列化，但<strong>除了</strong> <code>static</code> 或 <code>transient</code> 修饰的成员 <a target="_blank" rel="noopener" href="https://blog.csdn.net/fd2025/article/details/119102936">静态变量为什么不能序列化</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在序列化的时候，并不保存静态变量，因为序列化保存的是【对象状态】，</span><br><span class="hljs-comment">// 而 static 变量时属于【类的状态】，因此序列化并不保存静态变量</span><br><br><span class="hljs-comment">// ObjectStreamClass.class 中有以下代码</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;<br>    Field[] clFields = cl.getDeclaredFields();<br>    ArrayList&lt;ObjectStreamField&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> Modifier.STATIC | Modifier.TRANSIENT; <span class="hljs-comment">// STATIC 与 TRANSIENT</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; clFields.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((clFields[i].getModifiers() &amp; mask) == <span class="hljs-number">0</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectStreamField</span>(clFields[i], <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>    <span class="hljs-keyword">return</span> (size == <span class="hljs-number">0</span>) ? NO_FIELDS :<br>        list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectStreamField</span>[size]);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>序列化对象时，要求里面<strong>属性</strong>的类型也需要实现<strong>序列化接口</strong></p>
</li>
<li><p>序列化具备<strong>可继承性</strong>，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</p>
</li>
</ol>
</li>
</ol>
<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><ol>
<li><p>基本介绍</p>
<ol>
<li>对象处理流，提供了对基本类型或对象类型的<strong>反序列化</strong>方法</li>
<li>继承关系<ul>
<li>java.io.InputStream<ul>
<li>java.io.ObjectInputStream</li>
</ul>
</li>
</ul>
</li>
<li>实现接口<ul>
<li>Closeable</li>
<li>DateInput</li>
<li>ObjectInput</li>
<li>ObjectStreamConstants</li>
</ul>
</li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>protected ObjectInputStream()</code>: 为完全重新实现 <code>ObjectInputStream</code> 的子类提供一种方式，让它不必分配仅由 ObjectInputStream 的实现使用的私有数据</li>
<li><code>ObjectInputStream(InputStream in)</code>: 创建从指定 <code>InputStream</code> 读取的 <code>ObjectInputStream</code></li>
<li><code>int available()</code>: 返回可以不受阻塞地读取的字节数</li>
<li><code>void close()</code>: 关闭输入流</li>
<li><code>void defaultReadObject()</code>: 从此流读取当前类的非静态和非瞬态字段</li>
<li><code>protected boolean enableResolveObject(boolean enable)</code>: 使流允许从该流读取的对象被替代</li>
<li><code>int read()</code>: 读取数据字节</li>
<li><code>int read(byte[] buf, int off, int len)</code>: 读入 <code>byte</code> 数组</li>
<li><code>boolean readBoolean()</code>: 读取一个 <code>boolean</code> 值</li>
<li><code>byte readByte()</code>: 读取一个 <code>8</code> 位的字节</li>
<li><code>char readChar()</code>: 读取一个 <code>16</code> 位的 <code>char</code> 值</li>
<li><code>protected ObjectStreamClass readClassDescriptor()</code>: 从序列化流读取类描述符</li>
<li><code>double readDouble()</code>: 读取一个 <code>64</code> 位的 <code>double</code> 值</li>
<li><code>ObjectInputStream.GetField readFields()</code>: 按名称从流中读取持久字段并使其可用</li>
<li><code>float readFloat()</code>: 读取一个 <code>32</code> 位的 <code>float</code> 值</li>
<li><code>void readFully(byte[] buf)</code>: 读取字节，同时阻塞直至读取所有字节</li>
<li><code>void readFully(byte[] buf, int off, int len)</code>: 读取字节，同时阻塞直至读取所有字节</li>
<li><code>int readInt()</code>: 读取一个 <code>32</code> 位的 <code>int</code> 值</li>
<li><code>String readLine()</code>: 已过时此方法不能正确地将字节转换为字符。请参见 <code>DataInputStream</code> 以获取详细信息和替代方法</li>
<li><code>long readLong()</code>: 读取一个 <code>64</code> 位的 <code>long</code> 值</li>
<li><code>Object readObject()</code>: 从 <code>ObjectInputStream</code> 读取对象</li>
<li><code>protected Object readObjectOverride()</code>: 此方法由 <code>ObjectOutputStream</code> 的受信任子类调用，这些子类使用受保护的无参数构造方法构造 <code>ObjectOutputStream</code></li>
<li><code>short readShort()</code>: 读取一个 <code>16</code> 位的 <code>short</code> 值</li>
<li><code>protected void readStreamHeader()</code>: 提供的 <code>readStreamHeader</code> 方法允许子类读取并验证它们自己的流头部</li>
<li><code>Object readUnshared()</code>: 从 <code>ObjectInputStream</code> 读取“非共享”对象</li>
<li><code>int readUnsignedByte()</code>: 读取一个无符号的 <code>8</code> 位字节</li>
<li><code>int readUnsignedShort()</code>: 读取一个无符号的 <code>16</code> 位 <code>short</code> 值</li>
<li><code>String readUTF()</code>: 读取 <code>UTF-8</code> 修改版格式的 <code>String</code></li>
<li><code>void registerValidation(ObjectInputValidation obj, int prio)</code>: 在返回图形前注册要验证的对象</li>
<li><code>protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</code>: 加载指定流类描述的本地等价类</li>
<li><code>protected Object resolveObject(Object obj)</code>: 在反序列化期间，此方法允许 <code>ObjectInputStream</code> 的受信任子类使用一个对象替代另一个</li>
<li><code>protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)</code>: 返回一个代理类，该类实现在代理类描述符中命名的接口；子类可以实现此方法，以便从流及动态代理类的描述符中读取自定义数据，允许它们使用接口和代理类的替换加载机制</li>
<li><code>int skipBytes(int len)</code>: 跳过字节</li>
</ul>
</li>
<li><p>应用案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 ObjectInputStream 的使用，完成数据的反序列化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInputStream_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\data.dat&quot;</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br><br>            <span class="hljs-comment">// 1. 读取数据（反序列化）的顺序需要和保存数据（序列化）的顺序一致</span><br>            <span class="hljs-comment">// 2. 否则会出现异常</span><br>            System.out.println(ois.readInt());<br>            System.out.println(ois.readBoolean());<br>            System.out.println(ois.readChar());<br>            System.out.println(ois.readDouble());<br>            System.out.println(ois.readUTF());<br><br>            <span class="hljs-comment">// 底层 Object -&gt; Dog</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">readDog</span> <span class="hljs-operator">=</span> ois.readObject();<br>            System.out.println(<span class="hljs-string">&quot;dog 信息=&quot;</span> + readDog);<br>            System.out.println(readDog.getClass());<br><br>            <span class="hljs-comment">// 如果希望调用 Dog 的方法，需要向下转型</span><br>            <span class="hljs-comment">// 需要将 Dog 类放在到可以引用的位置</span><br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) readDog;<br>            System.out.println(dog.getName());<br><br>            <span class="hljs-comment">// 关闭流，关闭外层，底层会自动关闭</span><br>            ois.close();<br>            System.out.println(<span class="hljs-string">&quot;读取完毕！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><ol>
<li><p>基本介绍</p>
<ol>
<li>对象处理流，提供了对基本类型或对象类型的<strong>序列化</strong>方法</li>
<li>继承关系<ul>
<li>java.io.OutputStream<ul>
<li>java.io.ObjectOutputStream</li>
</ul>
</li>
</ul>
</li>
<li>实现接口<ul>
<li>Closeable</li>
<li>DateOutput</li>
<li>Flushable</li>
<li>ObjectOutput</li>
<li>ObjectStreamConstants</li>
</ul>
</li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>protected ObjectOutputStream()</code>: 为完全重新实现 <code>ObjectOutputStream</code> 的子类提供一种方法，让它不必分配仅由 <code>ObjectOutputStream</code> 的实现使用的私有数据</li>
<li><code>ObjectOutputStream(OutputStream out)</code>: 创建写入指定 <code>OutputStream</code> 的 <code>ObjectOutputStream</code></li>
<li><code>protected void annotateClass(Class&lt;?&gt; cl)</code>: 子类可以实现此方法，从而允许在流中存储类数据</li>
<li><code>protected void annotateProxyClass(Class&lt;?&gt; cl)</code>: 子类可以实现此方法，从而在流中存储定制数据和动态代理类的描述符</li>
<li><code>void close()</code>: 关闭流</li>
<li><code>void defaultWriteObject()</code>: 将当前类的非静态和非瞬态字段写入此流</li>
<li><code>protected void drain()</code>: 排空 <code>ObjectOutputStream</code> 中的所有已缓冲数据</li>
<li><code>protected boolean enableReplaceObject(boolean enable)</code>: 允许流对流中的对象进行替换</li>
<li><code>void flush()</code>: 刷新该流的缓冲</li>
<li><code>ObjectOutputStream.PutField putFields()</code>: 获取用于缓冲写入流中的持久存储字段的对象</li>
<li><code>protected  Object replaceObject(Object obj)</code>: 在序列化期间，此方法允许 <code>ObjectOutputStream</code> 的受信任子类使用一个对象替代另一个对象</li>
<li><code>void reset()</code>: 重置将丢弃已写入流中的所有对象的状态</li>
<li><code>void useProtocolVersion(int version)</code>: 指定要在写入流时使用的流协议版本</li>
<li><code>void write(byte[] buf)</code>: 写入一个 <code>byte</code> 数组</li>
<li><code>void write(byte[] buf, int off, int len)</code>: 写入字节的子数组</li>
<li><code>void write(int val)</code>: 写入一个字节</li>
<li><code>void writeBoolean(boolean val)</code>: 写入一个 <code>boolean</code> 值</li>
<li><code>void writeByte(int val)</code>: 写入一个 <code>8</code> 位字节</li>
<li><code>void writeBytes(String str)</code>: 以字节序列形式写入一个 <code>String</code></li>
<li><code>void writeChar(int val)</code>: 写入一个 <code>16</code> 位的 <code>char</code> 值</li>
<li><code>void writeChars(String str)</code>: 以 <code>char</code> 序列形式写入一个 <code>String</code></li>
<li><code>protected void writeClassDescriptor(ObjectStreamClass desc)</code>: 将指定的类描述符写入 ObjectOutputStream</li>
<li><code>void writeDouble(double val)</code>: 写入一个 <code>64</code> 位的 <code>double</code> 值</li>
<li><code>void writeFields()</code>: 将已缓冲的字段写入流中</li>
<li><code>void writeFloat(float val)</code>: 写入一个 <code>32</code> 位的 <code>float</code> 值</li>
<li><code>void writeInt(int val)</code>: 写入一个 <code>32</code> 位的 <code>int</code> 值</li>
<li><code>void writeLong(long val)</code>: 写入一个 <code>64</code> 位的 <code>long</code> 值</li>
<li><code>void writeObject(Object obj)</code>: 将指定的对象写入 <code>ObjectOutputStream</code></li>
<li><code>protected void writeObjectOverride(Object obj)</code>: 子类用于重写默认 <code>writeObject</code> 方法的方法</li>
<li><code>void writeShort(int val)</code>: 写入一个 <code>16</code> 位的 <code>short</code> 值</li>
<li><code>protected void writeStreamHeader()</code>: 提供 <code>writeStreamHeader</code> 方法，这样子类可以将其自身的头部添加或预加到流中</li>
<li><code>void writeUnshared(Object obj)</code>: 将「未共享」对象写入 <code>ObjectOutputStream</code></li>
<li><code>void writeUTF(String str)</code>: 以 <code>UTF-8</code> 修改版格式写入此 <code>String</code> 的基本数据</li>
</ul>
</li>
<li><p>应用案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 ObjectOutputStream 的使用，完成数据的序列化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectOutputStream_</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 序列化后，保存的文件格式，不是文本，而是按照它的格式来保存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\data.dat&quot;</span>;<br><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br><br>            <span class="hljs-comment">// 序列化数据到 e:\data.dat</span><br>            oos.writeInt(<span class="hljs-number">100</span>); <span class="hljs-comment">// int -&gt; Integer (实现了 Serializable)</span><br>            oos.writeBoolean(<span class="hljs-literal">true</span>); <span class="hljs-comment">// boolean -&gt; Boolean (实现了 Serializable)</span><br>            oos.writeChar(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// char -&gt; Character (实现了 Serializable)</span><br>            oos.writeDouble(<span class="hljs-number">9.5</span>);<br>            oos.writeUTF(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// String</span><br><br>            <span class="hljs-comment">// 创建一个 public class Dog 类</span><br>            <span class="hljs-comment">// 保存一个 Dog 对象</span><br>            oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>, <span class="hljs-number">10</span>));<br><br>            oos.close(); <span class="hljs-comment">// 刷新并关闭流，释放资源</span><br>            System.out.println(<span class="hljs-string">&quot;数据保存完毕（序列化形式）: e:\\data.dat&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="转换处理流（重点）"><a href="#转换处理流（重点）" class="headerlink" title="转换处理流（重点）"></a>转换处理流（重点）</h3><ol>
<li><p>编码问题引出转换流</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeQuestion</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeQuestion</span>().m1();<br>        System.out.println(<span class="hljs-string">&quot;\n===============&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeQuestion</span>().m2();<br>    &#125;<br><br>    <span class="hljs-comment">// 中文乱码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 读取 e:\\a.txt 到程序</span><br>        <span class="hljs-comment">// 1. 创建字符输入流 BufferedReader [处理流]</span><br>        <span class="hljs-comment">// 2. 使用 BufferedReader 对象读取 a.txt</span><br>        <span class="hljs-comment">// 3. 在使用非 utf-8 编码时，有可能出现中文乱码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\a.txt&quot;</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> br.readLine();<br>            System.out.print(str);<br><br>            br.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 解决中文乱码 -&gt; 使用转换处理流</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\a.txt&quot;</span>;<br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-type">int</span> readLen;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            isr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), <span class="hljs-string">&quot;utf-8&quot;</span>);<br>            <span class="hljs-keyword">while</span> ((readLen = isr.read(cbuf)) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cbuf, <span class="hljs-number">0</span>, readLen));<br>            &#125;<br>            isr.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<ol>
<li><code>InputStreamReader</code> 可以将 <code>InputStream(字节流)</code> 包装（转换）成 <code>Reader(字符流)</code></li>
<li><code>OutputStreamWriter</code> 可以将 <code>OutputStream(字节流)</code> 包装（转换）成 <code>Writer(字符流)</code></li>
<li>当处理<strong>纯文本数据</strong>时，使用<strong>字符流</strong>效率更高，并且可以有效解决<strong>中文问题</strong>，所以建议将<strong>字节流</strong>转换成<strong>字符流</strong></li>
<li>可以在使用时指定编码格式，比如：<code>utf-8</code>, <code>gbk</code>, <code>gb2312</code>, <code>ISO8859-1</code> 等</li>
</ol>
</li>
</ol>
<h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><ol>
<li><p>基本介绍</p>
<ol>
<li>继承关系<ul>
<li>java.io.Reader<ul>
<li>java.io.InputStreamReader<ul>
<li>java.io.FileReader</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实现接口<ul>
<li>Closeable</li>
<li>Readable</li>
<li>AutoCloseable</li>
</ul>
</li>
<li>可以将 <code>InputStream(字节流)</code> 包装成 <code>Reader(字符流)</code></li>
<li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流</li>
<li>可以在使用时指定编码格式，比如：<code>utf-8</code>, <code>gbk</code>, <code>gb2312</code>, <code>ISO8859-1</code> 等</li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的 <code>InputStreamReader</code></li>
<li><code>InputStreamReader(InputStream in, Charset cs)</code>: 创建使用指定字符集的 <code>InputStreamReader</code></li>
<li><code>InputStreamReader(InputStream in, CharsetDecoder dec)</code>: 创建使用指定字符集解码器的 <code>InputStreamReader</code></li>
<li><strong><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建使用指定字符集的 <code>InputStreamReader</code> （自定义编码方式）</strong></li>
<li><code>void close()</code>: 关闭该流并释放与之关联的所有资源</li>
<li><code>String getEncoding()</code>: 返回此流使用的字符编码的名称</li>
<li><code>int read()</code>: 读取单个字符</li>
<li><code>int read(char[] cbuf, int offset, int length)</code>: 将字符读入数组中的某一部分</li>
<li><code>boolean ready()</code>: 判断此流是否已经准备好用于读取</li>
</ul>
</li>
<li><p>应用案例<br> 将字节流 <code>FileInputStream</code> 包装成字符流 <code>InputStreamReader</code>，对文件进行读取（按照 <code>utf-8/gbk</code> 格式），进而再包装成 <code>BufferedReader</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 InputStreamReader 的使用</span><br><span class="hljs-comment"> * 解决中文乱码问题</span><br><span class="hljs-comment"> * 将字节流转换成字符流，指定编码 utf-8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\story.txt&quot;</span>;<br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1. 把 FileInputStream 转成 InputStreamReader</span><br>            <span class="hljs-comment">// 2. 同时指定编码为 utf-8</span><br>            isr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), <span class="hljs-string">&quot;gbk&quot;</span>);<br>            <span class="hljs-comment">// 3. 把 InputStreamReader 传入 BufferedReader</span><br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>            <span class="hljs-comment">// 4. 读取</span><br>            String readLine;<br>            <span class="hljs-keyword">while</span> ((readLine = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(readLine);<br>            &#125;<br>            <span class="hljs-comment">// 5. 关闭外层流</span><br>            br.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><ol>
<li><p>基本介绍</p>
<ol>
<li>继承关系<ul>
<li>Writer<ul>
<li>OutputStreamWriter</li>
</ul>
</li>
</ul>
</li>
<li>实现接口<ul>
<li>Flushable</li>
<li>Closeable</li>
<li>Appendable</li>
<li>AutoCloseable</li>
</ul>
</li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>OutputStreamWriter(OutputStream out)</code>: 创建使用默认字符编码的 <code>OutputStreamWriter</code></li>
<li><code>OutputStreamWriter(OutputStream out, Charset cs)</code>: 创建使用给定字符集的 <code>OutputStreamWriter</code></li>
<li><code>OutputStreamWriter(OutputStream out, CharsetEncoder enc)</code>: 创建使用给定字符集编码器的 <code>OutputStreamWriter</code></li>
<li><strong><code>OutputStreamWriter(OutputStream out, String charsetName)</code>: 创建使用指定字符集的 <code>OutputStreamWriter</code> （自定义编码方式）</strong></li>
<li><code>void close()</code>: 关闭此流，但要先刷新它</li>
<li><code>void flush()</code>: 刷新该流的缓冲</li>
<li><code>String getEncoding()</code>: 返回此流使用的字符编码的名称</li>
<li><code>void write(char[] cbuf, int off, int len)</code>: 写入字符数组的某一部分</li>
<li><code>void write(int c)</code>: 写入单个字符</li>
<li><code>void write(String str, int off, int len)</code>: 写入字符串的某一部分</li>
</ul>
</li>
<li><p>应用案例<br> 将字节流 <code>FileOutputStream</code> 包装成字符流 <code>OutputStreamWriter</code>， 对文件进行写入（指定编码 <code>utf-8/gbk</code>），再包装成 <code>BufferedWriter</code>，最后用 <code>BufferedReader</code> 读取</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 OutputStreamWriter 转换流的使用</span><br><span class="hljs-comment"> * 把 FileOutputStream 字节流转成 OutputStreamWriter字符流</span><br><span class="hljs-comment"> * 指定处理的编码方式 gbk/utf-8/utf8</span><br><span class="hljs-comment"> * 并使用 BufferedWriter 写入文件</span><br><span class="hljs-comment"> * 使用 BufferedReader 读取文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\b.txt&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">charSet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;utf8&quot;</span>;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            bw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath), charSet));<br>            bw.write(<span class="hljs-string">&quot;你好，世界&quot;</span>);<br>            bw.close(); <span class="hljs-comment">// 关闭流</span><br>            System.out.println(<span class="hljs-string">&quot;========写入完毕！========&quot;</span>);<br><br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), charSet));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">readLine</span> <span class="hljs-operator">=</span> br.readLine();<br>            System.out.println(readLine);<br>            br.close(); <span class="hljs-comment">// 关闭流</span><br>            System.out.println(<span class="hljs-string">&quot;========读取完毕！========&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="打印处理流-Print"><a href="#打印处理流-Print" class="headerlink" title="打印处理流 Print"></a>打印处理流 Print</h3><p>说明：</p>
<ol>
<li>打印流只有输出流，没有输入流</li>
</ol>
<h4 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h4><ol>
<li><p>基本介绍</p>
<ol>
<li><code>PrintStream</code> 为字节流</li>
<li>继承关系与实现接口<br> <img src="/img/java_learn/mk-2022-06-23-12-26.png" srcset="/img/loading.gif" lazyload alt="PrintStream 类图"></li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li>构造方法<ul>
<li><code>PrintStream(File file)</code></li>
<li><code>PrintStream(File file, String csn)</code></li>
<li><code>PrintStream(File file, Charset charset)</code></li>
<li><code>PrintStream(OutputStream out)</code></li>
<li><code>PrintStream(OutputStream out, boolean autoFlush)</code></li>
<li><code>PrintStream(OutputStream out, boolean autoFlush, String encoding)</code></li>
<li><code>PrintStream(OutputStream out, boolean autoFlush, Charset charset)</code></li>
<li><code>PrintStream(String fileName)</code></li>
<li><code>PrintStream(String fileName, String csn)</code></li>
<li><code>PrintStream(String fileName, Charset charset)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用演示</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 PrintStream 字节打印流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintStream_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> System.out;<br>        <span class="hljs-comment">// 在默认情况下，PrintStream 输出数据的位置为 标准输出，即显示器</span><br>        out.print(<span class="hljs-string">&quot;john, hello\n&quot;</span>); <span class="hljs-comment">// 底层使用 write() 方法</span><br>        <span class="hljs-comment">// 因为 print 底层使用的是 write() 方法，所以可以直接使用 write() 方法进行输出</span><br>        out.write(<span class="hljs-string">&quot;hello, 你好&quot;</span>.getBytes());<br>        out.close();<br><br>        <span class="hljs-comment">// 可以修改打印流输出的位置</span><br>        <span class="hljs-comment">// 输出位置修改为 &quot;e:\f1.txt&quot;</span><br>        System.setOut(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;e:\\f1.txt&quot;</span>));<br>        System.out.print(<span class="hljs-string">&quot;hello, 世界&quot;</span>); <span class="hljs-comment">// 输出到 &quot;e:\\f1.txt&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h4><ol>
<li><p>基本介绍</p>
<ol>
<li><code>PrintWriter</code> 为字符流</li>
<li>继承关系与实现接口<br> <img src="/img/java_learn/mk-2022-06-23-12-31.png" srcset="/img/loading.gif" lazyload alt="PrintWriter 类图"></li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li>构造方法<ul>
<li><code>PrintWriter(File file)</code></li>
<li><code>PrintWriter(File file, String csn)</code></li>
<li><code>PrintWriter(File file, Charset charset)</code></li>
<li><code>PrintWriter(OutputStream out)</code></li>
<li><code>PrintWriter(OutputStream out, boolean autoFlush)</code></li>
<li><code>PrintWriter(OutputStream out, boolean autoFlush, Charset charset)</code></li>
<li><code>PrintWriter(Writer out)</code></li>
<li><code>PrintWriter(Writer out, boolean autoFlush)</code></li>
<li><code>PrintWriter(String fileName)</code></li>
<li><code>PrintWriter(String fileName, String csn)</code></li>
<li><code>PrintWriter(String fileName, Charset charset)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用演示</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示 PrintWriter 字符打印流的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintWriter_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// PrintWriter printWriter = new PrintWriter(System.out);</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">printWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;e:\\f2.txt&quot;</span>));<br>        printWriter.print(<span class="hljs-string">&quot;hi, 你好&quot;</span>);<br>        printWriter.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><ol>
<li><p>基本介绍</p>
<ol>
<li><p>类的关系<br> <img src="/img/java_learn/mk-2022-06-23-16-52.png" srcset="/img/loading.gif" lazyload alt="Properties 类"></p>
</li>
<li><p>Properties 是专门用于读写配置文件的集合类<br> 配置文件的格式：<br> <code>键=值</code><br> <code>键=值</code></p>
<ul>
<li>注意：键值对不需要有空格，值不需要用引号，默认类型是 <code>String</code></li>
</ul>
</li>
</ol>
</li>
<li><p>常用方法</p>
<ul>
<li><code>load</code>: 加载配置文件的键值对到 <code>Properties</code> 对象</li>
<li><code>list</code>: 将数据显示到指定设备（流对象）</li>
<li><code>getProperty(key)</code>: 根据键获取值</li>
<li><code>setProperty(key, value)</code>: 设置键值对到 <code>Properties</code> 对象</li>
<li><code>store</code>: 将 <code>Properties</code> 中的键值对存储到配置文件，在 <code>idea</code> 中，保存信息到配置文件，如果含有中文，会存储为 <code>unicode</code> 码</li>
</ul>
</li>
<li><p>使用 Properties 类与传统方法对比</p>
<ul>
<li><p>如下配置文件：<code>mysql.properties</code></p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">ip<span class="hljs-operator">=</span><span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.13</span><br><span class="hljs-keyword">user</span><span class="hljs-operator">=</span>root<br>pwd<span class="hljs-operator">=</span><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>传统方法读取 <code>ip</code>, <code>user</code> 和 <code>pwd</code> 的值</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Properties01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 传统方法读取 mysql.properties</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;myJava\\src\\com\\chapter18\\properties_\\mysql.properties&quot;</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        String line;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath));<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                String[] split = line.split(<span class="hljs-string">&quot;=&quot;</span>);<br>                System.out.println(split[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;的值为&quot;</span> + split[<span class="hljs-number">1</span>]);<br>            &#125;<br><br>            br.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Properties</code> 类</p>
<ol>
<li>使用 <code>Properties</code> 类完成对 <code>mysql.properties</code> 的读取</li>
<li>使用 <code>Properties</code> 类添加 <code>key-val</code> 到新文件 <code>mysql2.properties</code> 中</li>
<li>使用 <code>Properties</code> 类完成对 <code>mysql2.properties</code> 的读取，并修改某个 <code>key-val</code></li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Properties02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties02</span>().m1();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties02</span>().m2();<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Properties 类完成对 mysql.properties 的读取</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;myJava\\src\\com\\chapter18\\properties_\\mysql.properties&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1. 创建 Properties 对象</span><br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><br>            <span class="hljs-comment">// 2. 加载配置文件</span><br>            properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br><br>            <span class="hljs-comment">// 把 k-v 显示到控制台</span><br>            properties.list(System.out);<br>            System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><br>            <span class="hljs-comment">// 根据 key 获取对应的 value</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;pwd&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;用户名：&quot;</span> + user);<br>            System.out.println(<span class="hljs-string">&quot;密码：&quot;</span> + pwd);<br>            System.out.println(<span class="hljs-string">&quot;读取配置文件成功！&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Properties 类添加 key-val 到新文件 mysql2.properties 中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 创建</span><br>        <span class="hljs-comment">// 如果该文件没有 key，就是创建</span><br>        <span class="hljs-comment">// 如果该文件有 key，就是修改</span><br>        properties.setProperty(<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-string">&quot;192.168.1.1&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;汤姆&quot;</span>); <span class="hljs-comment">// 保存时，是中文的 unicode 值</span><br>        properties.setProperty(<span class="hljs-string">&quot;pwd&quot;</span>, <span class="hljs-string">&quot;666666&quot;</span>); <span class="hljs-comment">// 原密码</span><br>        properties.setProperty(<span class="hljs-string">&quot;pwd&quot;</span>, <span class="hljs-string">&quot;888888&quot;</span>); <span class="hljs-comment">// 新密码</span><br><br>        <span class="hljs-comment">// 将 k-v 存储到文件中</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;myJava\\src\\com\\chapter18\\properties_\\mysql2.properties&quot;</span>), <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;保存配置文件成功！&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---------------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="十八章课后练习"><a href="#十八章课后练习" class="headerlink" title="十八章课后练习"></a>十八章课后练习</h3><ol>
<li><p>创建文件与文件夹</p>
<ol>
<li>在判断 <code>e:\\</code> 盘下是否有文件夹 <code>MyTemp</code>，如果没有就创建 <code>MyTemp</code></li>
<li>在 <code>e:\\MyTemp</code> 目录下，创建文件 <code>hello.txt</code></li>
<li>如果 <code>hello.txt</code>已经存在，提示该文件已经存在，就不要再重复创建了</li>
<li>在 <code>hello.txt</code> 文件中，写入 <code>hello, world!!</code>，并读取</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建文件与文件夹，写入文本内容并读取</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Homework01</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Homework01</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\MyTemp\\hello.txt&quot;</span>; <span class="hljs-comment">// 文件路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">writeTxt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, world!! 你好&quot;</span>; <span class="hljs-comment">// 写入文本</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建文件</span><br>            hm.createFile(filePath);<br><br>            <span class="hljs-comment">// 写入文本</span><br>            hm.writeFile(filePath, writeTxt);<br><br>            <span class="hljs-comment">// 读取文本</span><br>            System.out.println(<span class="hljs-string">&quot;--------文本内容--------&quot;</span>);<br>            hm.readFile(filePath);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建文件和文件夹，并判断文件与文件夹是否存在</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filePath : 文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFile</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建文件对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br><br>        <span class="hljs-comment">// 获取父级目录</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">parentPath</span> <span class="hljs-operator">=</span> file.getParent();<br><br>        <span class="hljs-comment">// 创建目录文件对象</span><br>        file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentPath);<br><br>        <span class="hljs-keyword">if</span> (file.exists()) &#123; <span class="hljs-comment">// 判断目录是否存在</span><br>            System.out.println(parentPath + <span class="hljs-string">&quot; 文件夹已存在！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!file.mkdir()) &#123; <span class="hljs-comment">// 创建目录并判断是否创建成功</span><br>                System.out.println(parentPath + <span class="hljs-string">&quot; 文件夹创建失败！&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(parentPath + <span class="hljs-string">&quot; 文件夹创建成功！&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建文件对象</span><br>        file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br><br>        <span class="hljs-keyword">if</span> (file.exists()) &#123; <span class="hljs-comment">// 判断文件是否存在</span><br>            System.out.println(filePath + <span class="hljs-string">&quot; 文件已存在！&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!file.createNewFile()) &#123; <span class="hljs-comment">// 创建文件并判断是否成功</span><br>            System.out.println(filePath + <span class="hljs-string">&quot; 文件创建失败！&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        System.out.println(filePath + <span class="hljs-string">&quot; 文件创建成功！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 把指定的文本写入文件中</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filePath : 文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> writeTxt : 将要写入的文本</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeFile</span><span class="hljs-params">(String filePath, String writeTxt)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        bw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath));<br>        bw.write(writeTxt);<br>        System.out.println(<span class="hljs-string">&quot;文本写入成功！&quot;</span>);<br><br>        bw.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath));<br>        String readLine;<br><br>        <span class="hljs-keyword">while</span> ((readLine = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(readLine);<br>        &#125;<br><br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>读取文件并加上行号</p>
<ul>
<li>使用 BufferedReader 读取一个文本文件，为每行加上行号，连同内容一并输出到屏幕上</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 读取文件并加上行号</span><br><span class="hljs-comment"> * 读取 &quot;e:\\story.txt&quot; (gbk 编码)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Homework02</span>().read(<span class="hljs-string">&quot;e:\\story.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), <span class="hljs-string">&quot;gbk&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> br.readLine();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(++count + <span class="hljs-string">&quot; &quot;</span> + line);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;读取完毕！&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>)<br>            br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Properties 类操作</p>
<ol>
<li><p>编写一个 <code>dog.properties</code> 有以下内容：</p>
 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">tom</span><br><span class="hljs-attr">age</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">color</span>=<span class="hljs-string">red</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>编写 <code>Dog</code> 类（<code>name, age, color</code>）创建一个 <code>Dog</code> 对象，读取 <code>dog.properties</code> 用相应的内容完成属性初始化，并输出</p>
</li>
<li><p>将创建的 <code>Dog</code> 对象，序列化到 <code>dog.dat</code> 文件中</p>
</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义文件路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\MyTemp\\hm03.txt&quot;</span>;<br><br>        <span class="hljs-comment">// 1. 写入参数到配置文件</span><br>        <span class="hljs-comment">// 创建 Properties 对象</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.setProperty(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>);<br>            properties.setProperty(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>);<br>            properties.setProperty(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);<br>            properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath), <span class="hljs-literal">null</span>);<br>            System.out.println(<span class="hljs-string">&quot;配置文件创建成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 读取 dog.properties 用相应的内容完成属性初始化，并输出 dog</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseInt(properties.getProperty(<span class="hljs-string">&quot;age&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;color&quot;</span>);<br><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(name, age, color);<br>        System.out.println(dog);<br><br>        <span class="hljs-comment">// 3. 序列化到 dog.dat 文件中</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">dataPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\MyTemp\\dog.dat&quot;</span>;<br>        m1(dog, dataPath); <span class="hljs-comment">// 序列化</span><br>        m2(dataPath); <span class="hljs-comment">// 反序列化并输出</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataPath : 序列化输出路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj      : 需要序列化的对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">(Object obj, String dataPath)</span> &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dataPath));<br>            oos.writeObject(obj);<br>            System.out.println(<span class="hljs-string">&quot;序列化成功！&quot;</span>);<br><br>            oos.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataPath: 数据路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">(String dataPath)</span> &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(dataPath));<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">readObject</span> <span class="hljs-operator">=</span> ois.readObject();<br>            System.out.println(<span class="hljs-string">&quot;反序列化成功！&quot;</span>);<br>            System.out.println(readObject);<br><br>            ois.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String color;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog [age=&quot;</span> + age + <span class="hljs-string">&quot;, color=&quot;</span> + color + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="十九、网络编程"><a href="#十九、网络编程" class="headerlink" title="十九、网络编程"></a>十九、网络编程</h2><h3 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h3><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ol>
<li>概念：两台或多台设备通过一定<strong>物理设备</strong>连接起来构成了网络</li>
<li>根据网络的覆盖范围不同，对网络进行分类：<ul>
<li>局域网：覆盖范围<strong>最小</strong>，仅仅覆盖一个教室或一个机房</li>
<li>城域网：覆盖范围<strong>较大</strong>，可以覆盖一个城市</li>
<li>广域网：覆盖范围<strong>最大</strong>，可以覆盖全国，甚至全球，万维网是广域网的代表</li>
</ul>
</li>
</ol>
<p><img src="/img/java_learn/mk-2022-06-24-16-54.png" srcset="/img/loading.gif" lazyload alt="网络示意图"></p>
<h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><ol>
<li>概念：两台设备之间通过<strong>网络</strong>实现<strong>数据传输</strong></li>
<li>网络通信：将数据通过网络从一台设备传输到另一台设备</li>
<li><code>java.net</code> 包下提供了一系列的类或接口，供程序员使用，完成网络通信</li>
</ol>
<p><img src="/img/java_learn/mk-2022-06-24-16-48.png" srcset="/img/loading.gif" lazyload alt="网络通信示意图"></p>
<h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><ol>
<li>概念：用于<strong>唯一标识</strong>网络中的每台计算机&#x2F;主机</li>
<li>查看 IP 地址：<code>ipconfig</code></li>
<li>IP 地址的表示形式：点分十进制 <code>XX.XX.XX.XX</code></li>
<li>每一个十进制数的范围：<code>0~255</code></li>
<li>IP 地址的组成 &#x3D; <code>网络地址 + 主机地址</code>。比如：<code>192.168.16.69</code>，C 类地址，<code>192.168.16</code> 为网络地址，<code>69</code> 为主机地址</li>
<li>IPV6 是互联网工程任务组设计的用于替代 IPV4 的下一代 IP 协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址</li>
<li>由于 IPV4 最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPV6 的使用，不仅能解决网蜂地址资源数的问题，而且也解决了多种接入设备连入互的障碍</li>
</ol>
<p><img src="/img/java_learn/mk-2022-06-24-17-18.png" srcset="/img/loading.gif" lazyload alt="IP 地址"><br><img src="/img/java_learn/mk-2022-06-24-17-22.png" srcset="/img/loading.gif" lazyload alt="IPV4 地址分类"></p>
<h4 id="域名和端口"><a href="#域名和端口" class="headerlink" title="域名和端口"></a>域名和端口</h4><ul>
<li><p>域名</p>
<ol>
<li>如：<code>www.baidu.com</code></li>
<li>概念：将 IP 地址映射成域名</li>
<li>好处：为了方便记忆，解决记 IP 的因难</li>
</ol>
</li>
<li><p>端口号</p>
<ol>
<li>概念：用于标识计算机上某个特定的网络程序</li>
<li>表示形式：以整数形式，范围 <code>0~65535</code>（2 个字节表示端口 <code>0~2^16-1</code>）</li>
<li><code>0~1024</code>已经被占用，在网络开发中，不要使用 <code>0~1024</code> 端口比如 <code>ssh 22, ftp 21, smtp 25, http 80</code></li>
<li>常见的网络程序端口号：<ul>
<li><code>tomcat:8080</code></li>
<li><code>mysql:3306</code></li>
<li><code>oracle:1521</code></li>
<li><code>sqlserver:1433</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/img/java_learn/mk-2022-06-24-17-59.png" srcset="/img/loading.gif" lazyload alt="域名和端口"></p>
<h4 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h4><ol>
<li><p>概念<br> 协议（TCP&#x2F;IP）：Transmission ControlProtocol&#x2F;Internet Protocol 的简写，中文译名为<strong>传输控制协议&#x2F;因特网互联协议</strong>，又叫<strong>网络通讯协议</strong>，这个协议是 Internet 最基本的协议，以及 Internet 国际互联网络的基础，简单地说，就是由网络层的 IP 协议和传输层的 TCP 协议组成的</p>
</li>
<li><p>网络协议的理解<br> <img src="/img/java_learn/mk-2022-06-26-11-23.png" srcset="/img/loading.gif" lazyload alt="网络协议的理解"></p>
</li>
<li><p>数据进入协议栈时的封装过程<br> <img src="/img/java_learn/mk-2022-06-26-11-14.png" srcset="/img/loading.gif" lazyload alt="数据进入协议栈时的封装过程"></p>
</li>
<li><p>以太网数据帧的分用过程<br> <img src="/img/java_learn/mk-2022-06-26-11-15.png" srcset="/img/loading.gif" lazyload alt="以太网数据帧的分用过程"></p>
</li>
<li><p>协议模型介绍</p>
<table>
<thead>
<tr>
<th align="center">OSI 模型（理论，已过时）</th>
<th align="center">TCP&#x2F;IP 模型</th>
<th align="center">TCP&#x2F;IP 模型各层对应协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">应用层</td>
<td align="center">HTTP、FTP、Telnet、DNS…</td>
</tr>
<tr>
<td align="center">表示层</td>
<td align="center">^ (向上合并单元格)</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">会话层</td>
<td align="center">^</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">传输层（TCP）</td>
<td align="center">TCP、UDP…</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">网络层（IP）</td>
<td align="center">IP、ICMP、ARP…</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td align="center">^</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">物理层</td>
<td align="center">物理 + 数据链路层</td>
<td align="center">Link</td>
</tr>
</tbody></table>
</li>
<li><p>TCP 和 UDP</p>
<ul>
<li><p>TCP 协议：传输控制协议</p>
<ol>
<li>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道</li>
<li>传输前，采用「<strong>三次握手</strong>」方式，确保数据可传输，是<strong>可靠</strong>的<br><img src="/img/java_learn/mk-2022-06-26-12-22.png" srcset="/img/loading.gif" lazyload alt="三次握手示意图"></li>
<li>TCP 协议进行通信的两个应用进程：客户端、服务端</li>
<li>在连接中可进行<strong>大数据量的传输</strong></li>
<li>传输完毕，需释放已建立的连接，效率低</li>
</ol>
</li>
<li><p>UDP 协议：用户数据协议</p>
<ol>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据报的大小限制在 64K 内，<strong>不适合传输大量数据</strong></li>
<li>因无需连接，故是<strong>不可靠</strong>的</li>
<li>发送数据结束时无需释放资源（因为不是面向连接的），速度快</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h3><ul>
<li><p>InetAddress 常用方法</p>
<ol>
<li><code>getLocalHost()</code>: 获取本机 <code>InetAddress</code> 对象，返回 <code>InetAddress</code> 对象</li>
<li><code>getByName()</code>: 根据指定 主机&#x2F;域名 获取 IP 地址对象，返回 <code>InetAddress</code> 对象</li>
<li><code>getHostName()</code>: 获取 <code>InetAddress</code> 对象的主机名，返回 <code>String</code></li>
<li><code>getHostAddress()</code>: 获取 <code>InetAddress</code> 对象的地址，返回 <code>String</code></li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InetAddress_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException &#123;<br><br>        <span class="hljs-comment">// 1. getLocalHost(): 获取本机 InetAddress 对象</span><br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">localHost</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>        System.out.println(localHost);<br><br>        <span class="hljs-comment">// 2. getByName(): 根据指定 主机/域名 获取 IP 地址对象</span><br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">byName</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;google.com&quot;</span>);<br>        System.out.println(byName);<br><br>        <span class="hljs-comment">// 3. getHostName(): 获取 InetAddress 对象的主机名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hostName</span> <span class="hljs-operator">=</span> byName.getHostName();<br>        System.out.println(hostName);<br><br>        <span class="hljs-comment">// 4. getHostAddress(): 获取 InetAddress 对象的地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hostAddress</span> <span class="hljs-operator">=</span> byName.getHostAddress();<br>        System.out.println(hostAddress);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul>
<li><p>Socket 基本介绍</p>
<ol>
<li>套接字（<code>Socket</code>）开发网络应用程序被广泛采用，以至于成为事实上的标准</li>
<li>通信的<strong>两端</strong>都要有 <code>Socket</code>，是两台机器间通信的端点</li>
<li>网络通信其实就是 <code>Socket</code> 间的通信。</li>
<li><code>Socket</code> 允许程序把网络连接当成一个流，数据在两个 <code>Socket</code> 间通过 IO 传输。</li>
<li>一般主动发起通信的应用程序属<strong>客户端</strong>，等待通信请求的为<strong>服务端</strong></li>
<li>客户端和服务端通常情况下，在不同的主机</li>
<li>Socket 的理解<br> <img src="/img/java_learn/mk-2022-06-26-15-55.png" srcset="/img/loading.gif" lazyload alt="Socket 的理解"></li>
</ol>
</li>
<li><p>基于 Socket 的两种编程方式</p>
<ol>
<li>TCP 编程</li>
<li>UDP 编程</li>
</ol>
</li>
<li><p>注意事项</p>
<ol>
<li>错误：Socket is not close<br> 不要在方法内关闭缓冲流，否则会造成重复关闭</li>
</ol>
</li>
</ul>
<h3 id="TCP-编程（重点）"><a href="#TCP-编程（重点）" class="headerlink" title="TCP 编程（重点）"></a>TCP 编程（重点）</h3><h4 id="TCP-编程基本介绍"><a href="#TCP-编程基本介绍" class="headerlink" title="TCP 编程基本介绍"></a>TCP 编程基本介绍</h4><ol>
<li>基于【客户端————服务端】的网络通信</li>
<li>底层使用的是 TCP&#x2F;IP 协议</li>
<li>应用场景举例：客户端发送数据，服务端接收并显示</li>
<li>基于 <code>Socket</code> 的 TCP 编程</li>
</ol>
<p><img src="/img/java_learn/mk-2022-06-26-15-59.png" srcset="/img/loading.gif" lazyload alt="TCP 编程介绍"></p>
<h4 id="TCP-编程应用案例"><a href="#TCP-编程应用案例" class="headerlink" title="TCP 编程应用案例"></a>TCP 编程应用案例</h4><ol>
<li><p>应用案例 1 （使用字节流）</p>
<ol>
<li>题目介绍<ol>
<li>编写一个服务器端，和一个客户端</li>
<li>服务器端在 <code>9999</code> 端口监听</li>
<li>客户端连接到服务器端，发送「hello, server」，然后退出</li>
<li>服务器端接收到客户端发送的信息，输出，并退出</li>
</ol>
</li>
<li>思路分析<br> <img src="/img/java_learn/mk-2022-06-26-19-28.png" srcset="/img/loading.gif" lazyload alt="思路分析"></li>
<li>代码实现<ul>
<li><p>服务端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 1 服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP01Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <br>        <span class="hljs-comment">// 1. 在本机的 9999 端口监听，等待连接</span><br>        <span class="hljs-comment">// ---- 要求在本机没有其他服务在监听 9999</span><br>        <span class="hljs-comment">// ---- 这个 ServerSocket 可以通过 accept() 返回多个 Socket（多个客户端连接服务器的并发）</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务端，在 9999 端口监听，等待连接..&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 当没有客户端连接 9999 端口时，程序会阻塞，等待连接</span><br>        <span class="hljs-comment">// ---- 如果没有客户端连接，则会返回 Socket 对象，程序继续</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        System.out.println(<span class="hljs-string">&quot;服务端 socket = &quot;</span> + socket.getClass());<br><br>        <span class="hljs-comment">// 3. 通过 socket.getInputStream() 读取客户端写入到数据通道的数据</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><br>        <span class="hljs-comment">// 4. IO 读取</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>]; <span class="hljs-comment">// 定义缓存</span><br>        <span class="hljs-type">int</span> readLen; <span class="hljs-comment">// 读取到的长度</span><br><br>        <span class="hljs-keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 根据读取到的实际长度，显示内容</span><br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen));<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 关闭流和 socket</span><br>        inputStream.close();<br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 1 客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP01Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException, IOException &#123;<br><br>        <span class="hljs-comment">// 1. 连接服务端 （ip，端口）</span><br>        <span class="hljs-comment">// ---- 连接本机的 9999 端口，如果连接成功，返回 Socket 对象</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getLocalHost(), <span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;客户端 socket 返回 = &quot;</span> + socket.getClass());<br><br>        <span class="hljs-comment">// 2. 连接上后，生成 Socket，通过 socket.getOutputStream()</span><br>        <span class="hljs-comment">// ---- 得到和 socket 对象关联的输出流对象</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>        <span class="hljs-comment">// 3. IO 流写入数据到 数据通道</span><br>        outputStream.write(<span class="hljs-string">&quot;hello, serve&quot;</span>.getBytes());<br><br>        <span class="hljs-comment">// 4. 关闭流对象和 socket</span><br>        outputStream.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>应用案例 2 （使用字节流）</p>
<ol>
<li>题目介绍<ol>
<li>编写一个服务端，和一个客户端</li>
<li>服务器端在 <code>9999</code> 端口监听</li>
<li>客户端连接到服务器端，发送「hello, server」，并接收服务器端回发的「hello, client」，再退出</li>
<li>服务器端接收到客户端发送的信息，输出，并发送「hello, client」，再退出</li>
</ol>
</li>
<li>思路分析<br> <img src="/img/java_learn/mk-2022-06-27-19-59.png" srcset="/img/loading.gif" lazyload alt="结束标记"></li>
<li>代码实现<ul>
<li><p>服务端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 2 服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP02Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1. 在本机的 9999 端口监听，等待连接</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务端 端口 9999 等待连接...&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 当没有客户端连接 9999 端口时，程序会阻塞，等待连接</span><br>        <span class="hljs-comment">// ---- 如果没有客户端连接，则会返回 Socket 对象，程序继续</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        System.out.println(<span class="hljs-string">&quot;服务端 socket = &quot;</span> + socket.getClass());<br><br>        <span class="hljs-comment">// 3. 通过 socket.getInputStream() 读取客户端写入到数据通道的数据</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><br>        <span class="hljs-comment">// 4. IO 读取并显示数据</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-type">int</span> readLen;<br>        <span class="hljs-keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen));<br>        &#125;<br>        <span class="hljs-comment">// 设置结束标记</span><br>        socket.shutdownInput();<br>        System.out.println(<span class="hljs-string">&quot;\n接收完毕！&quot;</span>);<br><br>        <span class="hljs-comment">// 5. 获取 socket 相关联的输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        outputStream.write(<span class="hljs-string">&quot;hello, client&quot;</span>.getBytes());<br>        <span class="hljs-comment">// 设置结束标记</span><br>        socket.shutdownOutput();<br>        System.out.println(<span class="hljs-string">&quot;发送完毕！&quot;</span>);<br><br>        <span class="hljs-comment">// 6. 关闭流和 socket</span><br>        inputStream.close();<br>        outputStream.close();<br>        socket.close();<br>        serverSocket.close();<br><br>        System.out.println(<span class="hljs-string">&quot;服务端退出...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 2 客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP02Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1. 连接服务端 （ip，端口）</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getLocalHost(), <span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;客户端 socket = &quot;</span> + socket.getClass());<br><br>        <span class="hljs-comment">// 2. 连接上后，生成 Socket，通过 socket.getOutputStream()</span><br>        <span class="hljs-comment">// ---- 得到和 socket 对象关联的输出流对象</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>        <span class="hljs-comment">// 3. IO 流写入数据到 数据通道</span><br>        outputStream.write(<span class="hljs-string">&quot;hello, server&quot;</span>.getBytes());<br>        <span class="hljs-comment">// 设置结束标记</span><br>        socket.shutdownOutput();<br>        System.out.println(<span class="hljs-string">&quot;发送完毕！&quot;</span>);<br><br>        <span class="hljs-comment">// 4. 获取 socket 相关联的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><br>        <span class="hljs-comment">// 5. 写入数据到数据通道</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-type">int</span> readLen;<br>        <span class="hljs-keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen));<br>        &#125;<br>        <span class="hljs-comment">// 设置结束标记</span><br>        socket.shutdownInput();<br>        System.out.println(<span class="hljs-string">&quot;\n接收完毕！&quot;</span>);<br><br>        <span class="hljs-comment">// 6. 关闭相关流</span><br>        outputStream.close();<br>        inputStream.close();<br>        socket.close();<br><br>        System.out.println(<span class="hljs-string">&quot;客户端退出...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>应用案例 3 （使用字符流）</p>
<ol>
<li>题目介绍<ol>
<li>编写一个服务器端，和一个客户端</li>
<li>服务器端在 <code>9999</code> 端口监听</li>
<li>客户端连接到服务器端，发送「hello,server」，并接收服务器端回发的「hello, client」，然后退出</li>
<li>服务器端接收到客户端发送的信息，输出，并发送「hello, client」，然后退出</li>
</ol>
</li>
<li>思路分析<br> <img src="/img/java_learn/mk-2022-06-28-10-22.png" srcset="/img/loading.gif" lazyload alt="应用案例 3 思路分析"></li>
<li>代码实现<ul>
<li><p>服务端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 3 服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP03Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务端 9999 等待连接&quot;</span>);<br><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">readLine</span> <span class="hljs-operator">=</span> br.readLine();<br>        System.out.println(readLine);<br><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>        bw.write(<span class="hljs-string">&quot;hello, client&quot;</span>);<br>        bw.newLine(); <span class="hljs-comment">// 插入一个换行符，表示写入的内容结束，要求另一端使用 readLine()</span><br>        bw.flush(); <span class="hljs-comment">// 如果使用字符流，需要手动刷新，否则数据不会写入数据通道</span><br><br>        <span class="hljs-comment">// 关闭流对象和 socket，先进后关</span><br>        bw.close();<br>        br.close();<br>        socket.close();<br>        serverSocket.close();<br><br>        System.out.println(<span class="hljs-string">&quot;服务端退出~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 3 客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP03Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException, IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getLocalHost(), <span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;客户端连接 9999 端口&quot;</span>);<br><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>        bw.write(<span class="hljs-string">&quot;hello, server&quot;</span>);<br>        bw.newLine(); <span class="hljs-comment">// 插入一个换行符，表示写入的内容结束，要求另一端使用 readLine()</span><br>        bw.flush(); <span class="hljs-comment">// 如果使用字符流，需要手动刷新，否则数据不会写入数据通道</span><br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">readLine</span> <span class="hljs-operator">=</span> br.readLine();<br>        System.out.println(readLine);<br><br>        <span class="hljs-comment">// 关闭流对象和 socket，先进后关</span><br>        br.close();<br>        bw.close();<br>        socket.close();<br><br>        System.out.println(<span class="hljs-string">&quot;客户端退出~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>应用案例 4 文件上传</p>
<ol>
<li><p>题目介绍</p>
<ol>
<li>编写一个服务端，和一个客户端</li>
<li>服务器端在 <code>8888</code> 端口监听</li>
<li>客户端连接到服务端，发送一张图片 <code>e:\\temp\\a\\1.jpg</code></li>
<li>服务器端接收到客户端发送的图片，保存到 <code>e:\\temp\\c\\1.jpg</code> 下，发送「收到图片」再退出</li>
<li>客户端接收到服务端发送的「收到图片」，再退出</li>
<li>该程序要求使用 <code>StreamUtils.java</code></li>
<li>使用 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 字节流</li>
</ol>
</li>
<li><p>思路分析<br> <img src="/img/java_learn/mk-2022-06-29-11-53.png" srcset="/img/loading.gif" lazyload alt="文件上传思路分析"></p>
</li>
<li><p>代码实现</p>
<ul>
<li><p>服务端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 4 文件上传服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPFileUploadServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 本机监听 8888端口</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务端 端口 8888 等待连接&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 等待连接</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>        <span class="hljs-comment">// 3. 获取客户端传入的数据</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-comment">// 获取客户端传入数据通道的数据</span><br>        <span class="hljs-type">byte</span>[] bytes = StreamUtils.streamToByteArray(inputStream);<br><br>        <span class="hljs-comment">// 4. 把数组中的数据写入文件</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\demo\\c\\1.jpg&quot;</span>;<br>        <span class="hljs-comment">// 创建缓冲字节流</span><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br>        bos.write(bytes);<br><br>        <span class="hljs-comment">// 5. 向客户端回复「收到图片」，通过 socket 获取到输出流（字符）</span><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>        writer.write(<span class="hljs-string">&quot;收到图片&quot;</span>);<br>        writer.flush(); <span class="hljs-comment">// 把内容刷新到数据通道</span><br>        socket.shutdownOutput(); <span class="hljs-comment">// 写入结束标记</span><br>        System.out.println(<span class="hljs-string">&quot;接收数据成功~&quot;</span>);<br><br>        writer.close();<br>        bos.close();<br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 案例 4 文件上传客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPFileUploadClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 客户端连接服务端，得到 Socket 对象，端口 8888</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getLocalHost(), <span class="hljs-number">8888</span>);<br>        System.out.println(<span class="hljs-string">&quot;客户端 端口 8888 连接成功&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 把磁盘上的图片读写到字节数组</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\demo\\a\\1.jpg&quot;</span>; <span class="hljs-comment">// 文件路径</span><br>        <span class="hljs-comment">// 创建读取磁盘文件的字节输入流</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br>        <span class="hljs-comment">// 获取字节数据，写入到 bytes</span><br>        <span class="hljs-type">byte</span>[] bytes = StreamUtils.streamToByteArray(bis);<br><br>        <span class="hljs-comment">// 3. 通过 socket 获取到输出流，发送数据到 -&gt;数据通道-&gt;服务端</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        outputStream.write(bytes); <span class="hljs-comment">// 写入到数据通道</span><br>        System.out.println(<span class="hljs-string">&quot;发送数据成功~&quot;</span>);<br>        socket.shutdownOutput(); <span class="hljs-comment">// 写入结束标记</span><br><br>        <span class="hljs-comment">// 4. 接收从服务端回复的消息</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-comment">// 使用 StreamUtils 的方法，直接将 InputStream 读取到的内容转成 String</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> StreamUtils.streamToString(inputStream);<br>        System.out.print(str);<br><br>        <span class="hljs-comment">// 4. 关闭流和 socket</span><br>        inputStream.close();<br>        outputStream.close();<br>        bis.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>StreamUtils 工具类</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类用于演示关于流的读写方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamUtils</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能 : 将输入流转换成 byte[]</span><br><span class="hljs-comment">     * 可以把文件的内容读入到 byte[]</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> is</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] streamToByteArray(InputStream is) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>(); <span class="hljs-comment">// 创建输出流对象</span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 创建字节数组</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = is.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len); <span class="hljs-comment">// 把读取到的数据，写入 bos</span><br>        &#125;<br>        <span class="hljs-type">byte</span>[] array = bos.toByteArray(); <span class="hljs-comment">// 将 bos 转成字节数组</span><br>        bos.close();<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能 : 将 InputStream 转换成 String</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> is</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">streamToString</span><span class="hljs-params">(InputStream is)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        String line;<br>        <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            builder.append(line + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="TCP-网络通信编程"><a href="#TCP-网络通信编程" class="headerlink" title="TCP 网络通信编程"></a>TCP 网络通信编程</h4><ol>
<li><p>netstat 指令</p>
<ol>
<li><code>netstat -an</code>: 可以查看当前主机网络情况，包括<strong>端口监听情况</strong>和<strong>网络连接情况</strong></li>
<li><code>netstat -an | more</code>: 可以分页显示</li>
<li><code>netstat -anb | more</code>: 显示注意网络情况和占用程序</li>
<li>要求在 <code>dos</code> 控制台下执行</li>
</ol>
<p> <img src="/img/java_learn/mk-2022-06-29-13-29.png" srcset="/img/loading.gif" lazyload alt="netstat 示意图"></p>
<ol>
<li>Listening 表示某个端口在监听</li>
<li>如果有一个外部程序（客户端）连接到该端口，就会显示一条连接信息</li>
</ol>
</li>
<li><p>TCP 网络通讯</p>
<ol>
<li>当客户端连接到服务端后，实际上客户端会由 TCP&#x2F;IP 来分配一个<strong>随机端口</strong>，客户端通过这个端口和服务端进行通讯，这个端口是不确定的、随机的</li>
<li>示意图<br> <img src="/img/java_learn/mk-2022-06-30-11-02.png" srcset="/img/loading.gif" lazyload alt="端口示意图"></li>
<li>程序验证 + netstat<br> <img src="/img/java_learn/mk-2022-06-30-11-21.png" srcset="/img/loading.gif" lazyload alt="客户端分配端口"></li>
</ol>
</li>
</ol>
<h3 id="UDP-编程（了解）"><a href="#UDP-编程（了解）" class="headerlink" title="UDP 编程（了解）"></a>UDP 编程（了解）</h3><ol>
<li><p>基本介绍</p>
<ol>
<li>类 <code>DatagramSocket(数据报套接字)</code> 和 <code>DatagramPacket(数据包/数据报)</code> 实现了基于 UDP 协议网络程序</li>
<li>UDP 数据报通过<strong>数据报套接字</strong> <code>DatagramSocket</code> 发送和接收，系统不保证 UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达，是不可靠的</li>
<li><code>DatagramPacket</code> 对象封装了 UDP 数据报，在数据报中包含了发送端的 IP 地址和端口号以及接收端的 IP 地址和端口号</li>
<li>UDP 协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</li>
</ol>
</li>
<li><p>基本流程</p>
<ol>
<li><p>核心的两个类&#x2F;对象 <code>DatagramSocket</code> 与 <code>DatagramPacket</code></p>
</li>
<li><p>建立<strong>发送端</strong>、<strong>接收端</strong>，没有服务端和客户端的概念</p>
</li>
<li><p>发送数据前，建立数据包&#x2F;报、<code>DatagramPacket</code> 对象</p>
</li>
<li><p>调用 <code>DatagramSocket</code> 的发送、接收方法</p>
</li>
<li><p>关闭 <code>DatagramSocket</code></p>
</li>
<li><p>UDP 网络编程原理示意图<br> <img src="/img/java_learn/mk-2022-07-01-17-54.png" srcset="/img/loading.gif" lazyload alt="UDP 网络编程原理示意图"></p>
<p> UDP 说明：</p>
<ol>
<li>没有明确的服务端和客户端，演变成数据的<strong>发送端</strong>和<strong>接收端</strong>，两者地位等同</li>
<li>接收数据和发送数据是通过 <code>DatagramSocket</code> 对像完成，</li>
<li>将数据封装到 <code>DatagramPacket</code> 对象（<strong>装包</strong>）</li>
<li>当接收到 <code>DatagramPacket</code> 对象，需要进行<strong>拆包</strong>，取出数据</li>
<li><code>DatagramSocket</code> 可以指定在哪个端口接收数据</li>
</ol>
</li>
</ol>
</li>
<li><p>应用案例</p>
<ol>
<li>题目介绍<ol>
<li>编写一个接收端 A，和一个发送端 B</li>
<li>接收端 A 在 9999 端口等待接收数据 (<code>receive</code>)</li>
<li>发送端 B 向接收端 A 发送数据「hello，明天吃火锅~」</li>
<li>接收端 A 接收到发送端 B 发送的数据，回复「好的，明天见」，再退出</li>
<li>发送端接收回复的数据，退出</li>
</ol>
</li>
<li>思路分析<br> <img src="/img/java_learn/mk-2022-07-02-11-55.png" srcset="/img/loading.gif" lazyload alt="UDP 案例思路分析"></li>
<li>代码实现<ul>
<li><p>接收端 A</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 接收端 A</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPReceiverA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1. 创建一个 DatagramSocket 对象，准备在 9999 端口接收数据</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">// 2. 创建一个 DatagramPacket 对象，准备接收数据</span><br>        <span class="hljs-comment">// --- UDP 每个数据包最大为 64K</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br><br>        <span class="hljs-comment">// 3. 调用接收方法，将通过网络传输的 DatagramPacket 对象填充到 dp 对象中</span><br>        <span class="hljs-comment">// --- 当有数据包发送到本机的 9999 端口时，就会接收到数据</span><br>        <span class="hljs-comment">// --- 如果没有数据包发送到 9999 端口时，就会阻塞等待</span><br>        System.out.println(<span class="hljs-string">&quot;接收端 A 等待接收数据...&quot;</span>);<br>        socket.receive(packet);<br><br>        <span class="hljs-comment">// 4. 拆包，取出数据，并显示</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> packet.getLength(); <span class="hljs-comment">// 实际接收到的数据字节长度</span><br>        <span class="hljs-type">byte</span>[] data = packet.getData(); <span class="hljs-comment">// 接收到的数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data, <span class="hljs-number">0</span>, length); <span class="hljs-comment">// 转换成 String</span><br>        System.out.println(s);<br><br>        <span class="hljs-comment">// 5. 回复数据到 B 端</span><br>        buf = <span class="hljs-string">&quot;好的，明天见&quot;</span>.getBytes();<br>        packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length, InetAddress.getByName(<span class="hljs-string">&quot;192.168.1.7&quot;</span>), <span class="hljs-number">9998</span>);<br>        socket.send(packet);<br><br>        <span class="hljs-comment">// 6. 关闭 DatagramSocket 对象</span><br>        socket.close();<br><br>        System.out.println(<span class="hljs-string">&quot;A 端退出...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>发送端 B</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送端 B</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPSenderB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1. 创建 DatagramSocket 对象，准备在 9998 端口接收数据</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">9998</span>);<br><br>        <span class="hljs-comment">// 2. 将需要发送的数据，封装到 DatagramPacket 对象</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-string">&quot;hello, 明天吃火锅~&quot;</span>.getBytes();<br><br>        <span class="hljs-comment">// 说明：封装的 DatagramPacket 对象 (data内容字节数据, data.length, 主机 (IP), 端口)</span><br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<br>                buf, buf.length, InetAddress.getByName(<span class="hljs-string">&quot;192.168.1.7&quot;</span>), <span class="hljs-number">9999</span>);<br><br>        <span class="hljs-comment">// 3. 发送数据</span><br>        System.out.println(<span class="hljs-string">&quot;发送数据中...&quot;</span>);<br>        socket.send(packet);<br><br>        <span class="hljs-comment">// 4. 接收 A 端回复的数据</span><br>        <span class="hljs-comment">// --- 监听 9998 端口</span><br>        packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br>        socket.receive(packet);  <br><br>        <span class="hljs-comment">// 5. 把接收到的数据进行拆包</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(), <span class="hljs-number">0</span>, packet.getLength());<br>        System.out.println(s);<br><br>        <span class="hljs-comment">// 6. 关闭对象</span><br>        socket.close();<br><br>        System.out.println(<span class="hljs-string">&quot;B 端退出...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="十九章课后练习"><a href="#十九章课后练习" class="headerlink" title="十九章课后练习"></a>十九章课后练习</h3><ol>
<li><p>TCP 编程</p>
<ol>
<li><p>题目要求</p>
<ol>
<li>使用字符流的方式，编写一个客户端程序和服务器端程序，</li>
<li>客户端发送「name」,服务器端接收到后，返回「我是 nova」</li>
<li>客户端发送「hobby」，服务器端接收到后，返回「编写 Java 程序」</li>
<li>如果不是这两个问题，回复「你说啥呢」</li>
</ol>
</li>
<li><p>代码实现</p>
<ul>
<li><p>服务器端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework01Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;9999 端口等待接收...&quot;</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(outputStream));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">readStr</span> <span class="hljs-operator">=</span> streamToString(inputStream);<br>        <span class="hljs-keyword">if</span> (readStr.equals(<span class="hljs-string">&quot;name&quot;</span>)) &#123;<br>            answer = <span class="hljs-string">&quot;我是 nova&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readStr.equals(<span class="hljs-string">&quot;hobby&quot;</span>)) &#123;<br>            answer = <span class="hljs-string">&quot;编写 java 程序&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            answer = <span class="hljs-string">&quot;你说啥&quot;</span>;<br>        &#125;<br><br>        bw.write(answer);<br>        bw.newLine();<br>        bw.flush();<br><br>        <span class="hljs-comment">// 关闭对象</span><br>        bw.close();<br>        outputStream.close();<br>        inputStream.close();<br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 将 InputStream 转成 String</span><br><span class="hljs-comment">    * </span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> is</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">streamToString</span><span class="hljs-params">(InputStream is)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> br.readLine();<br>        <span class="hljs-keyword">return</span> line;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework01Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException, IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getByName(<span class="hljs-string">&quot;192.168.0.140&quot;</span>), <span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;9999 端口连接成功~&quot;</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(outputStream));<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        System.out.print(<span class="hljs-string">&quot;请输入发送内容：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> scanner.next();<br><br>        bw.write(next);<br>        bw.newLine();<br>        bw.flush();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Homework01Server.streamToString(inputStream);<br><br>        System.out.println(str);<br><br>        <span class="hljs-comment">// 关闭对象</span><br>        bw.close();<br>        scanner.close();<br>        inputStream.close();<br>        outputStream.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>UDP 编程</p>
<ol>
<li>题目要求<ol>
<li>编写一个接收端 A，和一个发送端 B，使用 UDP 协议完成</li>
<li>接收端在 <code>9999</code> 端口等待接收数据</li>
<li>发送端向接收端发送数据「四大名著是哪些」</li>
<li>接收端接收到发送端发送的问题后，返回<code>四大名著是《红楼梦》…</code>，否则返回 <code>what?</code></li>
<li>接收端和发送端程序退出</li>
</ol>
</li>
<li>代码实现<ul>
<li><p>接收端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework02ReceiverA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">9999</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;等待接收数据..&quot;</span>);<br>        socket.receive(packet);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(), <span class="hljs-number">0</span>, packet.getLength());<br>        System.out.println(str);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;四大名著&quot;</span>.equals(str)) &#123;<br>            answer = <span class="hljs-string">&quot;&lt;&lt;三国演义&gt;&gt; &lt;&lt;西游记&gt;&gt; &lt;&lt;水浒传&gt;&gt; &lt;&lt;红楼梦&gt;&gt;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            answer = <span class="hljs-string">&quot;what? &quot;</span>;<br>        &#125;<br><br>        buf = answer.getBytes();<br>        packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<br>                buf, buf.length, InetAddress.getByName(<span class="hljs-string">&quot;192.168.0.140&quot;</span>), <span class="hljs-number">9998</span>);<br>        socket.send(packet);<br><br>        socket.close();<br>        System.out.println(<span class="hljs-string">&quot;接收端 A 退出..&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>发送端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework02SenderB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">9998</span>);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入问题：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> scanner.next();<br><br>        <span class="hljs-comment">// 将需要发送的数据，封装到 DatagramPacket 对象</span><br>        <span class="hljs-type">byte</span>[] buf = next.getBytes();<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<br>                buf, buf.length, InetAddress.getByName(<span class="hljs-string">&quot;192.168.0.140&quot;</span>), <span class="hljs-number">9999</span>);<br>        socket.send(packet);<br><br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br>        socket.receive(packet);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(), <span class="hljs-number">0</span>, packet.getLength());<br>        System.out.println(str);<br><br>        socket.close();<br>        scanner.close();<br>        System.out.println(<span class="hljs-string">&quot;发送端 B 退出..&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>从服务端下载文件</p>
<ol>
<li><p>题目介绍</p>
<ol>
<li>编写客户端程序和服务器端程序</li>
<li>客户端可以输入一个音乐文件名，比如「sonata」，服务端收到音乐名后，可以给客户端返回这个音乐文件，如果服务器没有这个文件，返回一个默认的音乐即可.</li>
<li>客户端收到文件后，保存到本地 <code>&quot;E:\MyTemp\Client\&quot;</code></li>
<li>提示：该程序可以使用 <code>StreamUtils</code> 工具类</li>
</ol>
</li>
<li><p>代码实现</p>
<ul>
<li><p>服务端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework03Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 监听 9999 端口</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">// 等待客户端连接</span><br>        System.out.println(<span class="hljs-string">&quot;服务端 9999 等待连接..&quot;</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>        <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>        <span class="hljs-comment">// 从数据通道接收客户端发来的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">readString</span> <span class="hljs-operator">=</span> StreamUtils.streamToString(is);<br><br>        String filePath; <span class="hljs-comment">// 要发送的文件路径</span><br>        <span class="hljs-comment">// 判断读取的字符串与文件名是否匹配</span><br>        <span class="hljs-comment">// 假设服务器端有两个文件，如果下载的是 abc.mp4，就返回该文件</span><br>        <span class="hljs-comment">// 否则一律返回 sonata.mp3 文件</span><br>        <span class="hljs-keyword">if</span> (readString.equals(<span class="hljs-string">&quot;waltz&quot;</span>)) &#123;<br>            filePath = <span class="hljs-string">&quot;E:\\MyTemp\\Server\\waltz.mp3&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            filePath = <span class="hljs-string">&quot;E:\\MyTemp\\Server\\sonata.mp3&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 发送指定文件到数据通道</span><br>        StreamUtils.sendFile(os, filePath);<br><br>        <span class="hljs-comment">// 关闭对象</span><br>        is.close();<br>        os.close();<br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework03Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 连接本机 9999 端口</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getByName(<span class="hljs-string">&quot;192.168.0.140&quot;</span>), <span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;客户端正在连接服务端 9999 端口..&quot;</span>);<br><br>        <span class="hljs-comment">// 获取文件流对象</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><br>        <span class="hljs-comment">// 创建 Scanner 对象，接收用户键盘输入</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入要下载的文件名：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> scanner.next();<br>        String filePath; <span class="hljs-comment">// 要保存的文件位置</span><br><br>        <span class="hljs-keyword">if</span> (next.equals(<span class="hljs-string">&quot;waltz&quot;</span>)) &#123;<br>            filePath = <span class="hljs-string">&quot;E:\\MyTemp\\Client\\waltz.mp3&quot;</span>;<br>            System.out.println(<span class="hljs-string">&quot;正在下载 waltz.mp3...&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            filePath = <span class="hljs-string">&quot;E:\\MyTemp\\Client\\sonata.mp3&quot;</span>;<br>            System.out.println(<span class="hljs-string">&quot;没有该文件，正在下载 sonata.mp3...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 向服务器发送要下载的文件名</span><br>        StreamUtils.sendString(os, next);<br><br>        <span class="hljs-comment">// 从数据通道接收数据，并保存到指定文件路径</span><br>        StreamUtils.receiveFile(is, filePath);<br><br>        System.out.println(<span class="hljs-string">&quot;下载成功！&quot;</span>);<br>        <span class="hljs-comment">// 关闭对象</span><br>        scanner.close();<br>        is.close();<br>        os.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>工具类</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Stream 工具类</span><br><span class="hljs-comment"> * 提示：不要关闭缓冲流！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamUtils</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能 : 将 InputStream 转换成 String</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> is</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">streamToString</span><span class="hljs-params">(InputStream is)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">readLine</span> <span class="hljs-operator">=</span> br.readLine();<br>        <span class="hljs-keyword">return</span> readLine;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能 : 将输入流转换成 byte[]</span><br><span class="hljs-comment">     * 可以把文件的内容读入到 byte[]</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> is</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] streamToByteArray(InputStream is) <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>(); <span class="hljs-comment">// 创建字节数组输出流对象</span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 创建字节数组</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = is.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len); <span class="hljs-comment">// 把读取到的数据，写入 bos</span><br>        &#125;<br>        <span class="hljs-type">byte</span>[] array = bos.toByteArray(); <span class="hljs-comment">// 将 bos 转成字节数组</span><br><br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能：发送字符串</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> os</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendString</span><span class="hljs-params">(OutputStream os, String str)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(os));<br>        bw.write(str);<br>        bw.newLine();<br>        bw.flush();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能：把文件读取到 byte[] 数组，并发送到数据通道</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> os</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filePath</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendFile</span><span class="hljs-params">(OutputStream os, String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取文件输入流对象</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br><br>        <span class="hljs-comment">// 把文件读取到字节数组</span><br>        <span class="hljs-type">byte</span>[] array = StreamUtils.streamToByteArray(fis);<br><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(os);<br>        bos.write(array); <span class="hljs-comment">// 发送到数据通道</span><br>        <span class="hljs-comment">// bos.flush();</span><br><br>        fis.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从数据通道接收文件，并保存到指定目录</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> is</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filePath</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveFile</span><span class="hljs-params">(InputStream is, String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">byte</span>[] array = StreamUtils.streamToByteArray(is);<br><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>        fos.write(array);<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="二十、多用户即时通信系统"><a href="#二十、多用户即时通信系统" class="headerlink" title="二十、多用户即时通信系统"></a>二十、多用户即时通信系统</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><ol>
<li><p>涉及到的内容</p>
<ul>
<li>项目框架设计</li>
<li>Java 面向对象编程</li>
<li>网络编程</li>
<li>多线程</li>
<li>IO 流</li>
<li>Mysql &#x2F; 使用集合充当内存数据库</li>
</ul>
</li>
<li><p>项目开发流程简介</p>
<ol>
<li>需求分析<ol>
<li>需求分析师</li>
<li>结合该项目功能，客户具体要求等出一个需求分析报告（白皮书）</li>
<li>懂技术 + 懂行业</li>
</ol>
</li>
<li>设计阶段<ol>
<li>架构师 &#x2F; 项目经理</li>
<li>设计工作：UML 类图、流程图、模块设计、数据库、架构等</li>
<li>原形开发</li>
<li>组建团队</li>
</ol>
</li>
<li>实现阶段<ol>
<li>程序员 &#x2F; 码农</li>
<li>完成架构师的模块功能</li>
<li>测试自己的模块</li>
</ol>
</li>
<li>测试阶段<ol>
<li>测试工程师</li>
<li>测试工作：单元测试、测试用例、白盒测试、黑盒测试、集成测试等</li>
<li>与实现阶段相辅相成</li>
</ol>
</li>
<li>实施阶段<ol>
<li>实施工程师</li>
<li>把项目正确的部署到客户的平台，并保证运行正常</li>
<li>要求对环境配置部署能力，身体好</li>
</ol>
</li>
<li>维护阶段<ol>
<li>发现 bug 解决</li>
<li>项目升级</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><ol>
<li>需求分析<ol>
<li>用户登录</li>
<li>拉取在线用户列表</li>
<li>无异常退出</li>
<li>私聊</li>
<li>群聊</li>
<li>发文件</li>
<li>服务器推送新闻</li>
</ol>
</li>
<li>界面设计<ol>
<li>用户登录</li>
<li>拉取在线用户列表</li>
<li>私聊</li>
<li>群聊</li>
<li>文件传输</li>
<li>服务器推送公告</li>
</ol>
</li>
</ol>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><ol>
<li><p>功能说明<br> 因为还没有学习数据库，我们人为规定 <code>用户名/id=100, 密码=123456</code> 就可以登录，其它用户暂时不能登录，后面使用 <code>HashMap</code> 模拟数据库，可以多个用户登录</p>
</li>
<li><p>思路分析 + 程序框架图<br> <img src="/img/java_learn/mk-2022-07-06-20-34.png" srcset="/img/loading.gif" lazyload alt="用户登录程序框架图"></p>
<ul>
<li><p>服务端</p>
<ol>
<li>当有客户端连接到服务器后，会得到一个 <code>Socket</code> 对象</li>
<li>启动一个线程，该线程持有该 <code>Socket</code> 对象，也就是说 <code>Socket</code> 是该线程的属性</li>
<li>为了更好的管理线程，需要使用集合来管理</li>
</ol>
</li>
<li><p>客户端</p>
<ol>
<li>和服务端通信时，使用对象方式，可以使用对象流来读写</li>
<li>当客户端连接到服务端后，也会得到 <code>Socket</code></li>
<li>启动一个线程，该线程持有 <code>Socket</code></li>
<li>为了更好管理线程，也将该线程放入到集合中</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="拉取在线用户列表"><a href="#拉取在线用户列表" class="headerlink" title="拉取在线用户列表"></a>拉取在线用户列表</h4><ol>
<li><p>功能说明<br> <img src="/img/java_learn/mk-2022-07-14-18-10.png" srcset="/img/loading.gif" lazyload alt="拉取在线用户列表"></p>
</li>
<li><p>思路分析 + 程序框架图<br> <img src="/img/java_learn/mk-2022-07-24-11-46.png" srcset="/img/loading.gif" lazyload alt="程序框架图"></p>
<ol>
<li>用户请求在线用户列表</li>
<li>客户端发送含有在线用户列表的 <code>Message</code> 对象，发送到数据通道</li>
</ol>
</li>
</ol>
<h4 id="无异常退出"><a href="#无异常退出" class="headerlink" title="无异常退出"></a>无异常退出</h4><ol>
<li><p>功能说明<br> <img src="/img/java_learn/mk-2022-07-24-12-12.png" srcset="/img/loading.gif" lazyload alt="无异常退出功能说明"></p>
</li>
<li><p>思路分析 + 程序框架图<br> <img src="/img/java_learn/mk-2022-07-24-12-30.png" srcset="/img/loading.gif" lazyload alt="无异常退出程序框架图"></p>
<ul>
<li><p>客户端</p>
<ol>
<li>在 <code>main</code> 线程调用方法，给服务器端发送一个退出系统的 <code>Message</code> 对象</li>
<li>调用 <code>System.exit(0)</code> 正常退出进程</li>
</ol>
</li>
<li><p>服务器端</p>
<ol>
<li>服务器端和某个客户端通信的线程接收到了一个退出系统的 <code>Message</code> 对象</li>
<li>把这个线程持有的 <code>Socket</code> 关闭</li>
<li>退出该线程的 <code>run()</code> 方法</li>
<li>退出线程</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="私聊"><a href="#私聊" class="headerlink" title="私聊"></a>私聊</h4><ol>
<li><p>功能说明<br> <img src="/img/java_learn/mk-2022-07-24-15-07.png" srcset="/img/loading.gif" lazyload alt="私聊功能说明"></p>
</li>
<li><p>思路分析 + 程序框架图<br> <img src="/img/java_learn/mk-2022-07-24-15-14.png" srcset="/img/loading.gif" lazyload alt="私聊程序框架图"></p>
<ul>
<li><p>客户端</p>
<ol>
<li>接收用户希望给某个其它在线用户聊天的内容</li>
<li>将消息封装成 <code>Message</code> 对象，通过对应的 <code>Socket</code> 发送给服务器</li>
<li>在通信线程中，读取到发送的 <code>Message</code> 消息，并显示</li>
</ol>
</li>
<li><p>服务器端</p>
<ol>
<li>可以读取到一个客户端发送给某个客户端的消息</li>
<li>从管理线程的集合中，根据 <code>Message</code> 的 <code>getterID</code> 获取到对应线程的 <code>Socket</code></li>
<li>将 <code>Message</code> 对象转发给指定客户</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h4><ol>
<li><p>功能说明<br> <img src="/img/java_learn/mk-2022-07-26-09-36.png" srcset="/img/loading.gif" lazyload alt="群聊功能说明"></p>
</li>
<li><p>思路分析</p>
<ol>
<li>遍历管理线程的 <code>hm</code> 集合</li>
<li>把所有线程的 <code>Socket</code> 得到</li>
<li>把 <code>Message</code> 对象进行转发</li>
</ol>
</li>
</ol>
<h4 id="发文件"><a href="#发文件" class="headerlink" title="发文件"></a>发文件</h4><p>跳过 P705 - P709</p>
<ol>
<li><p>功能说明<br> <img src="/img/java_learn/mk-2022-07-26-12-33.png" srcset="/img/loading.gif" lazyload alt="发文件功能说明"></p>
</li>
<li><p>思路分析 + 程序框架图<br> <img src="/img/java_learn/mk-2022-07-26-12-31.png" srcset="/img/loading.gif" lazyload alt="发文件程序框架图"></p>
<ul>
<li>把文件转为字节文件，写入到 <code>Message</code> 对象中</li>
</ul>
</li>
</ol>
<h4 id="服务器推送新闻"><a href="#服务器推送新闻" class="headerlink" title="服务器推送新闻"></a>服务器推送新闻</h4><ol>
<li><p>功能说明<br> <img src="/img/java_learn/mk-2022-07-26-12-34.png" srcset="/img/loading.gif" lazyload alt="服务器推送新闻"></p>
</li>
<li><p>思路分析 + 程序框架图<br> <img src="/img/java_learn/mk-2022-07-26-12-35.png" srcset="/img/loading.gif" lazyload alt="服务器推送新闻程序框架图"></p>
</li>
</ol>
<p>跳过 P705 - P709</p>
<h2 id="二十一、反射"><a href="#二十一、反射" class="headerlink" title="二十一、反射"></a>二十一、反射</h2><h3 id="引出反射"><a href="#引出反射" class="headerlink" title="引出反射"></a>引出反射</h3><ul>
<li>请看下面的问题<ol>
<li><p>根据配置文件 <code>re.properties</code> 指定信息，创建 <code>Cat</code> 对象并调用方法 <code>hi()</code></p>
</li>
<li><p>这样的需求在学习框架时特别多，即通过<strong>外部</strong>稳健配置，在<strong>不修改源码</strong>情况下，来<strong>控制程序</strong>或<strong>扩展功能</strong>，也符合设计模式的 <code>ocp</code> 原则（开闭原则）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">classfullpath=com.reflection.Cat<br>method=hi<br></code></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 反射问题的快速入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionQuestion</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 根据配置文件 re.properties 指定信息，创建 Cat 对象并调用方法 hi()</span><br>        <span class="hljs-comment">// 传统方式 1 : new 对象 -&gt; 调用方法</span><br>        <span class="hljs-comment">// Cat cat = new Cat();</span><br>        <span class="hljs-comment">// cat.hi();</span><br>        <span class="hljs-comment">// System.out.println(&quot;=============&quot;);</span><br><br>        <span class="hljs-comment">// 传统方式 2</span><br>        <span class="hljs-comment">// 1. 使用 Properties 类读取配置文件</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;myJava\\src\\com\\chapter21\\re.properties&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classfullpath</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;classfullpath&quot;</span>).toString(); <span class="hljs-comment">// &quot;com.chapter21.reflection.Cat&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;method&quot;</span>).toString(); <span class="hljs-comment">// &quot;hi&quot;</span><br>        System.out.println(<span class="hljs-string">&quot;classfullpath=&quot;</span> + classfullpath);<br>        System.out.println(<span class="hljs-string">&quot;method=&quot;</span> + methodName);<br><br>        <span class="hljs-comment">// 2. 创建对象，传统方法行不通</span><br><br>        <span class="hljs-comment">// 3. 使用反射机制解决（快速入门）</span><br>        <span class="hljs-comment">// (1) 加载类，返回 Class 类型的对象</span><br>        Class&lt;?&gt; cls = Class.forName(classfullpath);<br><br>        <span class="hljs-comment">// (2) 通过 cls 得到加载的类 com.reflection.Cat</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor().newInstance(); <span class="hljs-comment">// 运行类型为 Cat</span><br><br>        <span class="hljs-comment">// (3) 通过 cls 得到加载的类 com.reflection.Cat 的 methodName(&quot;hi&quot;) 的方法对象</span><br>        <span class="hljs-comment">// ----在反射中，可以把方法视为对象（万物皆对象）</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(methodName);<br><br>        <span class="hljs-comment">// (4) 通过 method 调用方法，即通过方法对象来实现调用方法</span><br>        method.invoke(cat); <span class="hljs-comment">// 方法.invoke(对象)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Cat 类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;招财猫&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><h4 id="Java-Reflection-基本介绍"><a href="#Java-Reflection-基本介绍" class="headerlink" title="Java Reflection 基本介绍"></a>Java Reflection 基本介绍</h4><ol>
<li><p>反射机制允许程序在执行期借勋于 <code>Reflection API</code> 取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能操作对象的属性及方法。反射常用于设计模式和框架底层</p>
</li>
<li><p>加载完类之后，在堆中就产生了一个 <code>Class</code>类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象包含了类的完整结构信息，所以可以通过这个对象得到类的结构。这个 <code>Class</code> 对象就像一面镜子，透过这个镜子看到类的结构，所以称之为：反射</p>
</li>
</ol>
<h4 id="Java-反射机制原理示意图（重要）"><a href="#Java-反射机制原理示意图（重要）" class="headerlink" title="Java 反射机制原理示意图（重要）"></a>Java 反射机制原理示意图（重要）</h4><p><img src="/img/java_learn/diagrams/Java%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.svg" srcset="/img/loading.gif" lazyload alt="Java 反射机制原理示意图"></p>
<h4 id="Java-反射机制的作用"><a href="#Java-反射机制的作用" class="headerlink" title="Java 反射机制的作用"></a>Java 反射机制的作用</h4><p>Java反射机制可以完成</p>
<ol>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时得到任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>生成动态代理</li>
</ol>
<h4 id="反射相关的主要类"><a href="#反射相关的主要类" class="headerlink" title="反射相关的主要类"></a>反射相关的主要类</h4><ol>
<li><code>java.lang.Class</code>: 代表一个类，<code>Class</code> 对象表示某个类加载后在堆中的对象</li>
<li><code>java.lang.reflect.Method</code>: 代表类的方法，<code>Method</code> 对象表示某个类的方法</li>
<li><code>java.lang.reflect.Field</code>: 代表类的成员变量，<code>Field</code> 对象表示某个类的成员变量</li>
<li><code>java.lang.reflect.Constructor</code>: 代表类的构造方法，<code>Constructor</code> 对象表示某个类的构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflection01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 使用 Properties 类读取配置文件</span><br>        <span class="hljs-comment">// 创建 Properties 对象</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 加载配置文件</span><br>        properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;myJava\\src\\com\\chapter21\\re.properties&quot;</span>));<br>        <span class="hljs-comment">// 通过 properties 获取 &quot;classfullpath&quot; 对应参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">classfullpath</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;classfullpath&quot;</span>).toString(); <span class="hljs-comment">// &quot;com.chapter21.reflection.Cat&quot;</span><br>        <span class="hljs-comment">// 通过 properties 获取 &quot;method&quot; 对应参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;method&quot;</span>).toString(); <span class="hljs-comment">// &quot;hi&quot;</span><br>        <span class="hljs-comment">// 输出</span><br>        System.out.println(<span class="hljs-string">&quot;classfullpath=&quot;</span> + classfullpath);<br>        System.out.println(<span class="hljs-string">&quot;method=&quot;</span> + methodName);<br><br>        <span class="hljs-comment">// 3. 使用反射机制解决</span><br>        <span class="hljs-comment">// (1) 加载类，返回 Class 类型的对象</span><br>        Class&lt;?&gt; cls = Class.forName(classfullpath);<br>        <span class="hljs-comment">// (2) 通过 cls 得到加载的类 com.chapter21.reflection.Cat</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor().newInstance(); <span class="hljs-comment">// 运行类型为 Cat</span><br><br>        <span class="hljs-comment">// 4. 反射相关类测试</span><br>        <span class="hljs-comment">// (1) java.lang.reflect.Method: 代表类的方法，Method 对象表示某个类的方法</span><br>        <span class="hljs-comment">// 通过 cls 得到加载的类 com.chapter21.reflection.Cat 的 methodName(&quot;hi&quot;) 的方法对象</span><br>        <span class="hljs-comment">// ----在反射中，可以把方法视为对象（万物皆对象）</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(methodName);<br>        <span class="hljs-comment">// 通过 method 调用方法，即通过方法对象来实现调用方法</span><br>        method.invoke(cat); <span class="hljs-comment">// 方法.invoke(对象)</span><br><br>        <span class="hljs-comment">// (2) java.lang.reflect.Field: 代表类的成员变量，Field 对象表示某个类的成员变量</span><br>        <span class="hljs-comment">// getField() 不能得到私有的属性</span><br>        <span class="hljs-comment">// 得到 name 字段</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-comment">// 传统写法 -&gt; 对象.成员变量；反射写法 -&gt; 成员变量对象.get(对象)</span><br>        System.out.println(ageField.get(cat));<br><br>        <span class="hljs-comment">// (3) java.lang.reflect.Constructor: 代表类的构造方法，Constructor 对象表示某个类的构造器</span><br>        <span class="hljs-comment">// 通过 Class 对象的 getConstructor() 方法 获取构造器对象</span><br>        <span class="hljs-comment">// ----() 中可以指定构造器参数类型，默认返回无参构造器</span><br>        Constructor&lt;?&gt; constructor = cls.getConstructor();<br>        System.out.println(constructor);<br>        <span class="hljs-comment">// 有参构造器</span><br>        <span class="hljs-comment">// 传入 String 类的 Class 对象</span><br>        Constructor&lt;?&gt; constructor2 = cls.getConstructor(String.class);<br>        System.out.println(constructor2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;招财猫&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 共有成员变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 无参构造器</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="反射优点和缺点"><a href="#反射优点和缺点" class="headerlink" title="反射优点和缺点"></a>反射优点和缺点</h4><ol>
<li>优点：可以<strong>动态</strong>的创建和使用对象（也是框架底层核心），使用灵活。如果没有反射机制，框架技术就失去底层支撑</li>
<li>缺点：使用反射基本是<strong>解释执行</strong>，对<strong>执行速度</strong>有影响</li>
</ol>
<h4 id="反射调用优化"><a href="#反射调用优化" class="headerlink" title="反射调用优化"></a>反射调用优化</h4><p>关闭访问检查</p>
<ol>
<li><code>Method</code>、<code>Field</code>、<code>Constructor</code> 对象都有 <code>setAccessible()</code> 方法</li>
<li><code>setAccessible</code> 作用是启动和禁用访问安全检查的开关</li>
<li>参数值为 <code>true</code> 表示反射的对像在使用时<strong>取消访问检查</strong>，提高反射的效率；参数值为 <code>false</code> 则表示反射的对象执行访问检查</li>
</ol>
<p>反射机制与传统方法耗时对比</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 反射机制与传统方法耗时对比</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflection02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        m1();<br>        m2();<br>        m3();<br>    &#125;<br><br>    <span class="hljs-comment">// 传统方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">90000000</span>; i++) &#123;<br>            dog.hi();<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;传统方法调用 hi() 耗时=&quot;</span> + (end - start) + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 反射机制</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-comment">// 获取 Class 对象</span><br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.Dog&quot;</span>);<br>        <span class="hljs-comment">// 获取 Cat 类对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor().newInstance();<br>        <span class="hljs-comment">// 获取 hi 方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hiMethod</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);<br>        <span class="hljs-comment">// 关闭访问检查</span><br>        hiMethod.setAccessible(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">90000000</span>; i++) &#123;<br>            hiMethod.invoke(dog);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射调用 hi() 耗时=&quot;</span> + (end - start) + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 反射调用优化 + 关闭访问检查</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-comment">// 获取 Class 对象</span><br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.Dog&quot;</span>);<br>        <span class="hljs-comment">// 获取 Cat 类对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor().newInstance();<br>        <span class="hljs-comment">// 获取 hi 方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hiMethod</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);<br>        <span class="hljs-comment">// 在调用方法时，关闭访问检查</span><br>        hiMethod.setAccessible(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">90000000</span>; i++) &#123;<br>            hiMethod.invoke(dog);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射优化调用 hi() 耗时=&quot;</span> + (end - start) + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><h4 id="Class-类基本介绍"><a href="#Class-类基本介绍" class="headerlink" title="Class 类基本介绍"></a>Class 类基本介绍</h4><ol>
<li><p><code>Class</code> 也是类，因此也继承 <code>Object</code> 类<br> <img src="/img/java_learn/mk-2022-07-29-12-54.png" srcset="/img/loading.gif" lazyload alt="Class 类图"></p>
</li>
<li><p><code>Class</code> 类对象不是 <code>new</code> 出来的，而是系统创建的</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Class 类对象不是 new 出来的，而是系统创建的</span><br><span class="hljs-comment">// (1) 传统 new 对象</span><br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">// Debug</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">ClassLoader 类</span><br><span class="hljs-comment">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="hljs-comment">        return loadClass(name, false);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// (2) 反射方式</span><br><span class="hljs-comment">// Debug 到 ClassLoader 类的 loadClass() 需要注释上面加载类的语句</span><br>Class&lt;?&gt; cls1 = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.Cat&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ClassLoader 类，仍然是通过 ClassLoader 类加载 Cat 类的 Class 对象</span><br><span class="hljs-comment">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="hljs-comment">        return loadClass(name, false);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>对于某个类的 <code>Class</code> 类对像，在内存中只有一份，因为类只加载一次</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Cat 类的 Class 类对象只能加载一次，是同一个加载器</span><br>Class&lt;?&gt; cls1 = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.Cat&quot;</span>);<br>Class&lt;?&gt; cls2 = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.Cat&quot;</span>);<br>System.out.println(cls1.hashCode()); <span class="hljs-comment">// 获取 cls1 的 HashCode</span><br>System.out.println(cls2.hashCode()); <span class="hljs-comment">// 获取 cls2 的 HashCode，相同</span><br>System.out.println(cls1.getClassLoader().hashCode()); <span class="hljs-comment">// 获取 cls1 加载器的 HashCode</span><br>System.out.println(cls2.getClassLoader().hashCode()); <span class="hljs-comment">// 获取 cls2 加载器的 HashCode，相同</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>每个类的实例都会记得自己是由哪个 <code>Class</code> 实例所生成</p>
</li>
<li><p>通过 <code>Class</code> 可以完整地得到一个类的完整结构，通过一系列 <code>API</code></p>
</li>
<li><p><code>Class</code> 对象是存放在堆的</p>
</li>
<li><p>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码变量名，方法名，访问权限等等) <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/38496907">查看链接</a></p>
</li>
</ol>
<h4 id="Class-类常用方法"><a href="#Class-类常用方法" class="headerlink" title="Class 类常用方法"></a>Class 类常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 类的全路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">classAllPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.chapter21.reflection.class_.Car&quot;</span>;<br><br>        <span class="hljs-comment">// 1. 获取到 Car 类</span><br>        <span class="hljs-comment">// &lt;?&gt; 表示不确定的 Java 类型</span><br>        Class&lt;?&gt; cls = Class.forName(classAllPath);<br><br>        <span class="hljs-comment">// 2. 输出 cls</span><br>        System.out.println(<span class="hljs-string">&quot;-------2-------&quot;</span>);<br>        <span class="hljs-comment">// 显示 cls 对象，是哪个类的 Class 对象</span><br>        <span class="hljs-comment">// class com.chapter21.reflection.class_.Car</span><br>        System.out.println(cls);<br>        <span class="hljs-comment">// 输出 cls 运行类型</span><br>        <span class="hljs-comment">// class java.lang.Class</span><br>        System.out.println(cls.getClass());<br><br>        <span class="hljs-comment">// 3. 得到包名</span><br>        System.out.println(<span class="hljs-string">&quot;-------3-------&quot;</span>);<br>        <span class="hljs-comment">// com.chapter21.reflection.class_</span><br>        System.out.println(cls.getPackageName());<br><br>        <span class="hljs-comment">// 4. 得到全类名</span><br>        System.out.println(<span class="hljs-string">&quot;-------4-------&quot;</span>);<br>        <span class="hljs-comment">// com.chapter21.reflection.class_.Car</span><br>        System.out.println(cls.getName());<br><br>        <span class="hljs-comment">// 5. 通过 cls 创建对象实例</span><br>        System.out.println(<span class="hljs-string">&quot;-------5-------&quot;</span>);<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> (Car) cls.getDeclaredConstructor().newInstance();<br>        System.out.println(car);<br><br>        <span class="hljs-comment">// 6. 通过反射获取属性 brand</span><br>        System.out.println(<span class="hljs-string">&quot;-------6-------&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;brand&quot;</span>);<br>        <span class="hljs-comment">// 输出 car 对象的 brand 属性对象的值</span><br>        System.out.println(brand.get(car));<br><br>        <span class="hljs-comment">// 7. 通过反射给属性赋值</span><br>        System.out.println(<span class="hljs-string">&quot;-------7-------&quot;</span>);<br>        brand.set(car, <span class="hljs-string">&quot;奔驰&quot;</span>);<br>        System.out.println(brand.get(car));<br><br>        <span class="hljs-comment">// 8. 遍历得到所有属性对象的值</span><br>        System.out.println(<span class="hljs-string">&quot;-------8-------&quot;</span>);<br>        Field[] fields = cls.getFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.get(car));<br>        &#125;<br><br>        <span class="hljs-comment">// 9. 通过反射获取方法</span><br>        System.out.println(<span class="hljs-string">&quot;-------9-------&quot;</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);<br>        hi.invoke(car);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;宝马&quot;</span>; <span class="hljs-comment">// 品牌</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;black&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car [brand=&quot;</span> + brand + <span class="hljs-string">&quot;, color=&quot;</span> + color + <span class="hljs-string">&quot;, price=&quot;</span> + price + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h4><ol>
<li><p>前提：已知一个类的全类名，且该类在类路径下，可通过 <code>Class</code> 类的静态方法 <code>forName()</code> 获取，可能抛出 <code>ClassNotFoundException</code> 异常</p>
<ul>
<li>实例：<code>Class cls1 = Class.forName(&quot;类的全类名&quot;)</code></li>
<li>应用场景：多用于配置文件，读取类全路径，加载类</li>
</ul>
</li>
<li><p>前提：若已知具体的类，通过类的 <code>.class</code> 获取，该方式最为安全可靠，程序性能最高</p>
<ul>
<li>实例：<code>Class cls2 = 类名.class</code></li>
<li>应用场景：多用于参数传递，比如通过反射得到对应构造器对象</li>
</ul>
</li>
<li><p>前提：已知某个类的实例，调用该实例的 <code>getClass()</code> 方法获取 <code>Class</code> 对象</p>
<ul>
<li>实例：<code>Class cls3 = 对象.getClass();</code></li>
<li>应用场景：通过创建好的对象，获取 <code>Class</code> 对象</li>
</ul>
</li>
<li><p>通过类加载器获取类的 <code>Class</code> 对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> 对象.getClass().getClassLoader();<br><span class="hljs-type">Class</span> <span class="hljs-variable">cls4</span> <span class="hljs-operator">=</span> cl.loadClass(<span class="hljs-string">&quot;类的全类名&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>基本数据类型（<code>int, char, boolean, float, double, byte, long, short</code>）获取 <code>Class</code> 对象</p>
<ul>
<li><code>Class cls = 基本数据类型.class</code></li>
</ul>
</li>
<li><p>基本数据类型对应的包装类，通过 <code>.TYPE</code> 获取 <code>Class</code> 对象</p>
<ul>
<li><code>Class cls = 包装类.TYPE</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 处于代码阶段</span><br>        <span class="hljs-comment">// 已知类的全类名，且该类在类路径下，多用于配置文件，读取类全路径，加载类</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">classAllPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.chapter21.reflection.class_.Cat&quot;</span>;<br>        Class&lt;?&gt; cls1 = Class.forName(classAllPath);<br>        System.out.println(<span class="hljs-string">&quot;cls1 = &quot;</span> + cls1);<br><br>        <span class="hljs-comment">// 2. 处于类的加载阶段</span><br>        <span class="hljs-comment">// 已知具体的类，通过类的 Class 获取，多用于参数传递</span><br>        Class&lt;?&gt; cls2 = Cat.class;<br>        System.out.println(<span class="hljs-string">&quot;cls2 = &quot;</span> + cls2);<br><br>        <span class="hljs-comment">// 3. 处于类的运行阶段</span><br>        <span class="hljs-comment">// 已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象</span><br>        <span class="hljs-comment">// 通过创建好的对象，获取 Class 对象</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        Class&lt;?&gt; cls3 = cat1.getClass(); <span class="hljs-comment">// 运行类型</span><br>        System.out.println(<span class="hljs-string">&quot;cls3 = &quot;</span> + cls3);<br><br>        <span class="hljs-comment">// 4. 通过类加载器（4种）获取类的 Class 对象</span><br>        <span class="hljs-comment">// 处于类的加载阶段</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">// 得到 cat2 的类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> cat2.getClass().getClassLoader();<br>        <span class="hljs-comment">// 通过类加载器得到 Class 对象</span><br>        Class&lt;?&gt; cls4 = cl.loadClass(classAllPath);<br>        System.out.println(<span class="hljs-string">&quot;cls4 = &quot;</span> + cls4);<br><br>        <span class="hljs-comment">// 这四个 Class 对象是同一个 Class 对象</span><br>        System.out.println(cls1 == cls2 &amp;&amp; cls1 == cls3 &amp;&amp; cls1 == cls4);<br><br>        <span class="hljs-comment">// 5. 基本数据类型获取 Class 对象</span><br>        Class&lt;?&gt; cls5 = <span class="hljs-type">int</span>.class;<br>        System.out.println(<span class="hljs-string">&quot;cls5 = &quot;</span> + cls5);<br><br>        <span class="hljs-comment">// 6. 基本数据类型对应的包装类获取 Class 对象</span><br>        Class&lt;?&gt; cls6 = Integer.TYPE;<br>        System.out.println(<span class="hljs-string">&quot;cls6 = &quot;</span> + cls6);<br><br>        <span class="hljs-comment">// cls5 和 cls6 是同一个对象</span><br>        System.out.println(cls5.hashCode());<br>        System.out.println(cls6.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="哪些类型有-Class-对象"><a href="#哪些类型有-Class-对象" class="headerlink" title="哪些类型有 Class 对象"></a>哪些类型有 Class 对象</h4><ol>
<li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li>
<li><code>interface</code>: 接口</li>
<li>数组</li>
<li><code>enum</code>: 枚举</li>
<li><code>annotation</code>: 注解</li>
<li>基本数据类型</li>
<li><code>void</code></li>
</ol>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="类加载基本说明"><a href="#类加载基本说明" class="headerlink" title="类加载基本说明"></a>类加载基本说明</h4><ul>
<li><p>反射机制是 <code>Java</code> 实现动态语言的关键，也就是通过反射实现类动态加载</p>
<ol>
<li><strong>静态加载</strong>：编译时加载相关的类，如果没有，则报错，依赖性较<strong>强</strong></li>
<li><strong>动态加载</strong>：运行时加载需要的类，只有运行使用该类时，才会报错，依赖性较<strong>弱</strong></li>
<li>类加载的时机<ol>
<li>当创建对象时（<code>new</code>）【静态加载】</li>
<li>当子类被加载时，父类也会被加载【静态加载】</li>
<li>调用类中的静态成员时【静态加载】</li>
<li>通过反射【动态加载】</li>
</ol>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoad_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入 key：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> scanner.next();<br>        <span class="hljs-keyword">switch</span>(key) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:<br>                <span class="hljs-comment">// 静态加载，编译报错</span><br>                <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>                dog.cry();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:<br>                <span class="hljs-comment">// 反射 -&gt; 动态加载，编译不报错，执行到这段代码时才会报错</span><br>                Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;Person&quot;</span>); <span class="hljs-comment">// 加载 Person 类</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor().newInstance();<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);<br>                hi.invoke(o);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;do nothing...&quot;</span>);<br>        &#125;<br>        scanner.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// new Dog() 是静态加载，所以必须编写 Dog 类，否则编译不通过</span><br><span class="hljs-comment">// Person 类是动态加载，所以没有编写 Person 类，编译不会报错，只有动态加载该类时，才会报错</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪叫...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="类加载流程图"><a href="#类加载流程图" class="headerlink" title="类加载流程图"></a>类加载流程图</h4><ul>
<li><p>类加载流程图<br>  <img src="/img/java_learn/mk-2022-08-02-10-58.png" srcset="/img/loading.gif" lazyload alt="类加载流程图"></p>
</li>
<li><p>类加载的各个阶段<br>  <img src="/img/java_learn/mk-2022-08-02-11-00.png" srcset="/img/loading.gif" lazyload alt="类加载的各个阶段"></p>
</li>
</ul>
<h4 id="类加载的各个阶段"><a href="#类加载的各个阶段" class="headerlink" title="类加载的各个阶段"></a>类加载的各个阶段</h4><p><img src="/img/java_learn/mk-2022-08-03-11-22.png" srcset="/img/loading.gif" lazyload alt="类加载的阶段"></p>
<ol>
<li><p><strong>加载阶段</strong><br><code>JVM</code> 在该阶段的主要目的是将字节码从不同的数据源（可能是 <code>class</code> 文件，也可能是 <code>jar</code> 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 <code>java.lang.Class</code> 对象</p>
</li>
<li><p><strong>连接阶段</strong></p>
<ol>
<li><p><strong>连接阶段-验证 Verification</strong></p>
<ol>
<li>目的是为了确保 <code>Class</code> 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>
<li>验证包括：文件格式验证（是否以字节码魔数 <code>0xCAFEBABE</code> 开头）、元数据验证、字节码验证和符号引用验证</li>
<li>可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间</li>
</ol>
</li>
<li><p><strong>连接阶段-准备 Preparation</strong><br> <code>JVM</code> 会在该阶段对静态变量分配内存并默认初始化（对应数据类型的默认初始值如 <code>0、OL、null、false</code> 等)。这些变量所使用的内存都将在方法区中进行分配</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 演示 类加载的连接阶段-准备</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoad02</span> &#123;<br>    <span class="hljs-comment">// 属性-成员变量-字段</span><br>    <span class="hljs-comment">// 分析 类加载的链接阶段-准备，属性是如何处理的</span><br>    <span class="hljs-comment">// 1. n1 是实例属性，不是静态变量，因此在准备阶段不会分配内存</span><br>    <span class="hljs-comment">// 2. n2 是静态变量，会分配内存，n2 默认初始化为 0，不是 20</span><br>    <span class="hljs-comment">// 3. n3 static final 是常量，一旦赋值就不会变化，所以会一次性赋值为 30</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>连接阶段-解析</strong></p>
<ul>
<li>虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>初始化阶段（Initialization）</strong></p>
<ol>
<li><p>到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 <code>clinit()</code> 方法的过程</p>
</li>
<li><p><code>clinit()</code> 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<strong>静态变量</strong>的赋值动作和<strong>静态代码块</strong>中的语句，并进行合并</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 类加载-初始化阶段</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoad03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 分析</span><br>        <span class="hljs-comment">// 1. 加载 B 类，并生成 B 的 Class 对象</span><br>        <span class="hljs-comment">// 2. 连接，num = 0</span><br>        <span class="hljs-comment">// 3. 初始化，自动收集类中的所有【静态变量】的赋值动作和【静态代码块】中的语句，并进行合并</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                clinit() &#123;</span><br><span class="hljs-comment">                    System.out.println(&quot;B 静态代码块被执行&quot;);</span><br><span class="hljs-comment">                    // num = 300; // 被合并</span><br><span class="hljs-comment">                    static int num  = 100;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                合并：num = 100;</span><br><span class="hljs-comment">            */</span><br><br>        <span class="hljs-comment">// new B(); // 类加载</span><br>        System.out.println(B.num); <span class="hljs-comment">// 100，如果直接使用类的静态属性，也会导致类的加载</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B 静态代码块被执行&quot;</span>);<br>        num = <span class="hljs-number">300</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span>  <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B 构造器被执行&quot;</span>);<br>    &#125;<br>&#125;        <br></code></pre></td></tr></table></figure>
</li>
<li><p>虚拟机会保证一个类的 <code>clinit()</code> 方法在多线程环境中被正确的<strong>加锁、同步</strong>，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>clinit()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>clinit()</code> 方法完毕。<strong>正是因为有这个机制，才能保证某个类在内存中，只有一个 <code>Class</code> 对象</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 正是因为有这个机制，才能保证某个类在内存中，只有一个 Class 对象</span><br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="反射获取类的结构信息"><a href="#反射获取类的结构信息" class="headerlink" title="反射获取类的结构信息"></a>反射获取类的结构信息</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>1.<code>getName</code>: 获取全类名<br>2.<code>getSimpleName</code>: 获取简单类名<br>3.<code>getFields</code>: 获取所有 <code>public</code> 修饰的属性，包含本类以及父类的<br>4.<code>getDeclaredFields</code>: 获取本类中所有属性<br>5.<code>getMethods</code>: 获取所有 <code>public</code> 修饰的方法，包含本类以及父类的<br>6.<code>getDeclaredMethods</code>: 获取本类中所有方法<br>7.<code>getConstructors</code>: 获取所有 <code>public</code> 修饰的构造器，包含本类以及父类的<br>8.<code>getDeclaredConstructors</code>: 获取本类中所有构造器<br>9.<code>getPackage</code>: 以 <code>Package</code> 形式返回包信息<br>10.<code>getSuperClass</code>: 以 <code>Class</code> 形式返回父类信息<br>11.<code>getInterfaces</code>: 以 <code>Class</code> 形试返回接口信息<br>12.<code>getAnnotations</code>: 以 <code>Annotation</code> 形式返回注解信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示通过反射获取类的结构信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionUtils</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">api01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 得到 Class 对象</span><br>        Class&lt;?&gt; personCls = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.getinfo.Person&quot;</span>);<br>        <span class="hljs-comment">// 1.getName: 获取全类名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> personCls.getName();<br>        System.out.println(name);<br>        <span class="hljs-comment">// 2.getSimpleName: 获取简单类名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">simpleName</span> <span class="hljs-operator">=</span> personCls.getSimpleName();<br>        System.out.println(simpleName);<br>        <span class="hljs-comment">// 3.getFields: 获取所有 public 修饰的属性，包含本类以及父类的</span><br>        Field[] fields = personCls.getFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类及父类的 public 属性：&quot;</span> + field.getName());<br>        &#125;<br>        <span class="hljs-comment">// 4.getDeclaredFields: 获取本类中所有属性</span><br>        Field[] declaredFields = personCls.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中的属性：&quot;</span> + field.getName());<br>        &#125;<br>        <span class="hljs-comment">// 5.getMethods: 获取所有 public 修饰的方法，包含本类以及父类的</span><br>        Method[] methods = personCls.getMethods();<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类及父类的 public 方法：&quot;</span> + method.getName());<br>        &#125;<br>        <span class="hljs-comment">// 6.getDeclaredMethods: 获取本类中所有方法</span><br>        Method[] declaredMethods = personCls.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method method : declaredMethods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中的方法：&quot;</span> + method.getName());<br>        &#125;<br>        <span class="hljs-comment">// 7.getConstructors: 获取所有 public 修饰的构造器，包含本类以及父类的</span><br>        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类及父类的 public 构造器：&quot;</span> + constructor);<br>        &#125;<br>        <span class="hljs-comment">// 8.getDeclaredConstructors: 获取本类中所有构造器</span><br>        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : declaredConstructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中的构造器：&quot;</span> + constructor);<br>        &#125;<br>        <span class="hljs-comment">// 9.getPackage: 以 Package 形式返回包信息</span><br>        <span class="hljs-type">Package</span> <span class="hljs-variable">package1</span> <span class="hljs-operator">=</span> personCls.getPackage();<br>        System.out.println(<span class="hljs-string">&quot;本类所在的包：&quot;</span> + package1.getName());<br>        <span class="hljs-comment">// 10.getSuperClass: 以 Class 形式返回父类信息</span><br>        Class&lt;?&gt; superclass = personCls.getSuperclass();<br>        System.out.println(<span class="hljs-string">&quot;父类：&quot;</span> + superclass.getName());<br>        <span class="hljs-comment">// 11.getInterfaces: 以 Class 形试返回接口信息</span><br>        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; anInterfaces : interfaces) &#123;<br>            System.out.println(<span class="hljs-string">&quot;接口信息：&quot;</span> + anInterfaces.getName());<br>        &#125;<br>        <span class="hljs-comment">// 12.getAnnotations: 以 Annotation 形式返回注解信息</span><br>        Annotation[] annotations = personCls.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(<span class="hljs-string">&quot;注解信息：&quot;</span> + annotation);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> String hobby;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-meta">@SuppressWarnings(&#123; &quot;unused&quot; &#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span>, IB &#123;<br><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>    String job;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> sal;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><ol>
<li><code>getModifiers</code>: 以 <code>int</code> 形式返回修饰符<ul>
<li><code>默认修饰符</code>: <code>0</code>，<code>public</code>: <code>1</code>，<code>private</code>: <code>2</code>，<code>protected</code>: <code>4</code>，<code>static</code>: <code>8</code>，<code>final</code>: <code>16</code>，<code>public static = 1 + 8 = 9</code></li>
</ul>
</li>
<li><code>getType</code>: 以 <code>Class</code> 形式返回类型</li>
<li><code>getName</code>: 返回属性名</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">api02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 得到 Class 对象</span><br>    Class&lt;?&gt; personCls = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.getinfo.Person&quot;</span>);<br><br>    <span class="hljs-comment">// getDeclaredFields: 获取本类中所有属性</span><br>    Field[] declaredFields = personCls.getDeclaredFields();<br>    <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>        System.out.println(<span class="hljs-string">&quot;本类中的属性：&quot;</span> + field +<br>                <span class="hljs-string">&quot;，\n该属性的修饰符值：&quot;</span> + field.getModifiers() +<br>                <span class="hljs-string">&quot;，\n该属性的类型：&quot;</span> + field.getType() + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">本类中的属性：<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.String com.chapter21.reflection.getinfo.Person.name，<br>该属性的修饰符值：<span class="hljs-number">9</span>，<br>该属性的类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br><br>本类中的属性：<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> com.chapter21.reflection.getinfo.Person.age，<br>该属性的修饰符值：<span class="hljs-number">20</span>，<br>该属性的类型：<span class="hljs-type">int</span><br><br>本类中的属性：java.lang.String com.chapter21.reflection.getinfo.Person.job，<br>该属性的修饰符值：<span class="hljs-number">0</span>，<br>该属性的类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br><br>本类中的属性：<span class="hljs-keyword">private</span> <span class="hljs-type">double</span> com.chapter21.reflection.getinfo.Person.sal，<br>该属性的修饰符值：<span class="hljs-number">2</span>，<br>该属性的类型：<span class="hljs-type">double</span><br></code></pre></td></tr></table></figure>

<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ol>
<li><code>getModifiers</code>: 以 <code>int</code> 形式返回修饰符<ul>
<li><code>默认修饰符</code>: <code>0</code>，<code>public</code>: <code>1</code>，<code>private</code>: <code>2</code>，<code>protected</code>: <code>4</code>，<code>static</code>: <code>8</code>，<code>final</code>: <code>16</code>，<code>public static = 1 + 8 = 9</code></li>
</ul>
</li>
<li><code>getReturnType</code>: 以 <code>Class</code> 形式返回类型</li>
<li><code>getName</code>: 返回方法名</li>
<li><code>getParameterTypes</code>: 以 <code>Class[]</code> 返回参数类型数组</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">api03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 得到 Class 对象</span><br>    Class&lt;?&gt; personCls = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.getinfo.Person&quot;</span>);<br><br>    <span class="hljs-comment">// getDeclaredMethods: 获取本类中所有方法</span><br>    Method[] methods = personCls.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法名称：&quot;</span> + method.getName() +<br>                <span class="hljs-string">&quot;，\n该方法的修饰符值：&quot;</span> + method.getModifiers() +<br>                <span class="hljs-string">&quot;，\n该方法的类型：&quot;</span> + method.getReturnType());<br>        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;<br>            System.out.println(<span class="hljs-string">&quot;该方法的参数类型：&quot;</span> + parameterType);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">方法名称：m2，<br>该方法的修饰符值：<span class="hljs-number">4</span>，<br>该方法的类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>该方法的参数类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.chapter21.reflection.getinfo.Person<br><br>方法名称：m1，<br>该方法的修饰符值：<span class="hljs-number">1</span>，<br>该方法的类型：<span class="hljs-keyword">void</span><br>该方法的参数类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>该方法的参数类型：<span class="hljs-type">double</span><br><br>方法名称：m3，<br>该方法的修饰符值：<span class="hljs-number">0</span>，<br>该方法的类型：<span class="hljs-keyword">void</span><br><br>方法名称：m4，<br>该方法的修饰符值：<span class="hljs-number">2</span>，<br>该方法的类型：<span class="hljs-type">boolean</span><br></code></pre></td></tr></table></figure>

<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><ol>
<li><code>getModifiers</code>: 以 <code>int</code> 形式返回修饰符<ul>
<li><code>默认修饰符</code>: <code>0</code>，<code>public</code>: <code>1</code>，<code>private</code>: <code>2</code>，<code>protected</code>: <code>4</code></li>
</ul>
</li>
<li><code>getName</code>: 返回构造器名（全类名）</li>
<li><code>getParameterTypes</code>: 以 <code>Class[]</code> 返回参数类型数组</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">api04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 得到 Class 对象</span><br>    Class&lt;?&gt; personCls = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.getinfo.Person&quot;</span>);<br><br>    <span class="hljs-comment">// getDeclaredConstructors: 获取本类中所有构造器</span><br>    Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();<br>    <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : declaredConstructors) &#123;<br>        System.out.println(<span class="hljs-string">&quot;本类中的构造器：&quot;</span> + constructor);<br>        System.out.println(<span class="hljs-string">&quot;该构造器的修饰符值：&quot;</span> + constructor.getModifiers());<br>        System.out.println(<span class="hljs-string">&quot;该构造器的名称：&quot;</span> + constructor.getName());<br><br>        Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;<br>            System.out.println(<span class="hljs-string">&quot;该构造器的参数类型：&quot;</span> + parameterType);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">本类中的构造器：<span class="hljs-keyword">private</span> com.chapter21.reflection.getinfo.Person(<span class="hljs-type">int</span>)<br>该构造器的修饰符值：<span class="hljs-number">2</span><br>该构造器的名称：com.chapter21.reflection.getinfo.Person<br>该构造器的参数类型：<span class="hljs-type">int</span><br><br>本类中的构造器：<span class="hljs-keyword">protected</span> com.chapter21.reflection.getinfo.Person(java.lang.String)<br>该构造器的修饰符值：<span class="hljs-number">4</span><br>该构造器的名称：com.chapter21.reflection.getinfo.Person<br>该构造器的参数类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br><br>本类中的构造器：<span class="hljs-keyword">public</span> com.chapter21.reflection.getinfo.Person()<br>该构造器的修饰符值：<span class="hljs-number">1</span><br>该构造器的名称：com.chapter21.reflection.getinfo.Person<br></code></pre></td></tr></table></figure>

<h3 id="反射暴破操作"><a href="#反射暴破操作" class="headerlink" title="反射暴破操作"></a>反射暴破操作</h3><blockquote>
<p>暴破，即暴力破解，使用反射访问 <code>private</code> 构造器、属性或方法</p>
</blockquote>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><ol>
<li><p>方式一：调用类中的 <code>public</code> 修饰的无参构造器</p>
</li>
<li><p>方式二：调用类中的指定构造器</p>
</li>
<li><p>Class 类相关方法</p>
<ul>
<li><code>newInstance</code>: 调用类中的无参构造器，获取对应类的对象（Java 17 中使用 <code>getDeclaredConstructor().newInstance()</code>）</li>
<li><code>getConstructor(Class...clazz)</code>: 根据参数列表，获取对应的 <code>public</code> 构造器对象</li>
<li><code>getDeclaredConstructor(Class...clazz)</code>: 根据参数列表，获取对应的所有构造器对象</li>
</ul>
</li>
<li><p><code>Constructor</code> 类相关方法</p>
<ul>
<li><code>setAccessible</code>: 暴破，即暴力破解，使用反射访问 <code>private</code> 构造器、属性或方法</li>
<li><code>newInstance(Object...obj)</code>: 调用构造器</li>
</ul>
</li>
<li><p>实例演示</p>
<ol>
<li>测试1：通过反射创建某类的对象，要求该类中必须有 public 的无参构造</li>
<li>测试2：通过调用某个特定构造器的方式，实现创建某类的对象</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用【暴破】访问 private 构造器、属性以及方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectCreateInstance</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 获取 User 类的 Class 对象</span><br>        Class&lt;?&gt; userClass = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 通过 public 的无参构造器创建实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClass.getDeclaredConstructor().newInstance();<br>        System.out.println(user);<br><br>        <span class="hljs-comment">// 3. 通过 public 的有参构造器创建实例</span><br>        <span class="hljs-comment">// 先得到构造器，再创建实例</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * String.class: 参数类型</span><br><span class="hljs-comment">         * &quot;Jack&quot;: 参数</span><br><span class="hljs-comment">         */</span><br>        Constructor&lt;?&gt; publicConstructor = userClass.getDeclaredConstructor(String.class);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">jack</span> <span class="hljs-operator">=</span> publicConstructor.newInstance(<span class="hljs-string">&quot;Jack&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;jack= &quot;</span> + jack);<br><br>        <span class="hljs-comment">// 4. 通过非 public 的有参构造器创建实例</span><br>        Constructor&lt;?&gt; privateConstructor = userClass.getDeclaredConstructor(<span class="hljs-type">int</span>.class, String.class);<br>        <span class="hljs-comment">// 暴破，使用反射可以访问 private 构造器、属性或方法</span><br>        privateConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">sam</span> <span class="hljs-operator">=</span> privateConstructor.newInstance(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;Sam&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;sam= &quot;</span> + sam);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Mary&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 无参 public</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name)</span> &#123; <span class="hljs-comment">// 有参 public</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123; &quot;unused&quot; &#125;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span> &#123; <span class="hljs-comment">// 有参 private</span><br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [age=&quot;</span> + age + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><ol>
<li>根据属性名获取 <code>Field</code> 对象<br> <code>getField</code>：<code>public</code> 属性<br> <code>getDeclaredField</code>：所有属性<br> <code>Field f = class对象.getDeclaredField(属性名);</code></li>
<li>暴破<br> <code>f.setAccessible(true); // f 是 Field</code></li>
<li>访问<br> <code>f.set(o, value); // o 表示 对象</code><br> <code>f.get(o);</code></li>
<li><strong>注意</strong>：如果是静态属性，则 <code>set</code> 和 <code>get</code> 中的参数 <code>o</code>，可以写成 <code>null</code></li>
</ol>
<p>实例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示反射操作属性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectAccessProperty</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 得到 Student 类对应的 Class 对象</span><br>        Class&lt;?&gt; stuClass = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.reflectaccess.Student&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 创建对象</span><br>        <span class="hljs-comment">// o 的运行类型为 Student</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> stuClass.getDeclaredConstructor().newInstance();<br>        System.out.println(o);<br><br>        <span class="hljs-comment">// 3. 使用反射得到 age 属性对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> stuClass.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>        age.set(o, <span class="hljs-number">88</span>); <span class="hljs-comment">// 通过反射来操作属性</span><br>        System.out.println(age.get(o));<br><br>        <span class="hljs-comment">// 4. 使用反射操作 私有的 name 属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stuClass.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴破</span><br>        <span class="hljs-comment">// name.set(o, &quot;Jack&quot;);</span><br>        name.set(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Jack&quot;</span>); <span class="hljs-comment">// static 属性，obj 参数可直接写成 null</span><br>        <span class="hljs-comment">// System.out.println(name.get(o));</span><br>        System.out.println(name.get(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// name 为静态属性，obj 参数可写成 null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 无参构造器</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student [age=&quot;</span> + age + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h4><ol>
<li>根据方法名和参数列表获取 <code>Method</code> 方法对象：<br> <code>getMethod</code>：<code>public</code> 方法<br> <code>getDeclaredMethod</code>：所有本类方法<br> <code>Method m = clazz.getDeclaredMethod(方法名，XX.class);</code></li>
<li>获取对象：<br> <code>Object o = clazz.getDeclaredConstructor.newInstance();</code></li>
<li>暴破：<br> <code>m.setAccessible(true); // m 为 Method 对象</code></li>
<li>访问方法：<br> <code>Object returnValue = m.invoke(o, 实参列表); // o 是对象</code></li>
<li><strong>注意</strong>：如果是静态方法，则 <code>invoke</code> 的参数 <code>o</code>，可以写成 <code>null</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 演示通过反射调用方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectAccessMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 得到 Boss 类对应的 Class 对象</span><br>        Class&lt;?&gt; bossClass = Class.forName(<span class="hljs-string">&quot;com.chapter21.reflection.reflectaccess.Boss&quot;</span>);<br>        <span class="hljs-comment">// 2. 创建对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> bossClass.getDeclaredConstructor().newInstance();<br>        <span class="hljs-comment">// 3. 调用 public 的 hi() 方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> bossClass.getDeclaredMethod(<span class="hljs-string">&quot;hi&quot;</span>, String.class);<br>        hi.invoke(o, <span class="hljs-string">&quot;Jack&quot;</span>);<br>        <span class="hljs-comment">// 4. 调用 private static 的 say() 方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">say</span> <span class="hljs-operator">=</span> bossClass.getDeclaredMethod(<span class="hljs-string">&quot;say&quot;</span>, <span class="hljs-type">int</span>.class, String.class, <span class="hljs-type">char</span>.class);<br>        say.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴破</span><br>        <span class="hljs-comment">// 在反射中，如果方法有返回值，统一返回 Object</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> say.invoke(o, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-string">&#x27;女&#x27;</span>); <span class="hljs-comment">// static 方法的 obj 参数可以传入 null</span><br>        System.out.println(returnValue);<br><br>        <span class="hljs-comment">// 因为 say() 是 static 的，还可以这样调用</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue2</span> <span class="hljs-operator">=</span> say.invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br>        System.out.println(returnValue2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boss</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Boss</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123; &quot;unused&quot; &#125;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">say</span><span class="hljs-params">(<span class="hljs-type">int</span> n, String s, <span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-string">&quot; &quot;</span> + s + <span class="hljs-string">&quot; &quot;</span> + c;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二十一章课后练习"><a href="#二十一章课后练习" class="headerlink" title="二十一章课后练习"></a>二十一章课后练习</h3><ol>
<li><p>练习 1：通过反射修改私有成员变量</p>
<ol>
<li>定义 <code>PrivateTest</code> 类，有私有 <code>name</code> 属性，并且属性值为 <code>helloKitty</code></li>
<li>提供 <code>getName()</code> 的公有方法</li>
<li>创建 <code>PrivateTest</code> 类的 <code>Class</code> 对象，利用 <code>Class</code> 对象得到私有的 <code>name</code> 属性，修改私有的 <code>name</code> 属性值，并调用 <code>getName()</code> 的方法打印 <code>name</code> 属性值</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过反射修改私有成员变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 得到 PrivateTest 对应的 Class 对象</span><br>        Class&lt;PrivateTest&gt; cls = PrivateTest.class;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">PrivateTest</span> <span class="hljs-variable">privateTest</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor().newInstance();<br>        <span class="hljs-comment">// 得到 name 属性对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> cls.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// 暴破 name</span><br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 修改 name 属性值</span><br>        name.set(privateTest, <span class="hljs-string">&quot;Jack&quot;</span>);<br>        <span class="hljs-comment">// 得到 getName 方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-comment">// 调用 getName() 方法，并输出 name 属性值</span><br>        System.out.println(getName.invoke(privateTest));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloKitty&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>练习 2：利用反射和 <code>File</code> 完成以下功能</p>
<ol>
<li>利用 <code>Class</code> 类的 <code>forName()</code> 方法得到 <code>File</code> 类的 <code>Class</code> 对象</li>
<li>在控制台打印 <code>File</code> 类的所有构造器</li>
<li>通过 <code>newInstance()</code> 的方法创建 <code>File</code> 对象，并创建 <code>E:\my.txt</code> 文件</li>
<li>提示：创建文件的正常写法如下：<br> <code>File file = new File(&quot;d:\aa.txt&quot;);</code><br> <code>file.createNewFile();</code></li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 反射与 File 类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 得到 File 类的 Class 对象</span><br>        Class&lt;?&gt; fileClass = Class.forName(<span class="hljs-string">&quot;java.io.File&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 打印 File 类的所有构造器</span><br>        Constructor&lt;?&gt;[] declaredConstructors = fileClass.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : declaredConstructors) &#123;<br>            System.out.println(constructor);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 通过 newInstance() 创建 File 对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileAllPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E:\\my.txt&quot;</span>;<br>        <span class="hljs-comment">// 创建 file 对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> fileClass.getDeclaredConstructor(String.class).newInstance(fileAllPath);<br><br>        <span class="hljs-comment">// 4. 得到 createNewFile 方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">createNewFile</span> <span class="hljs-operator">=</span> fileClass.getMethod(<span class="hljs-string">&quot;createNewFile&quot;</span>);<br>        <span class="hljs-comment">// 调用方法</span><br>        createNewFile.invoke(file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/">#学习</a>
      
        <a href="/tags/%E6%8A%80%E6%9C%AF/">#技术</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/05/java_learn/Java%E5%9F%BA%E7%A1%80%205/" title="Java基础 第五章">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java基础 第五章</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/05/java_learn/Java%E5%9F%BA%E7%A1%80%203/" title="Java基础 第三章">
                        <span class="hidden-mobile">Java基础 第三章</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
